	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.3r1 Build 19041558 SN 09003382"
	.compiler_invocation	"ctc --dep-file=0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6\\.nd6.o.d --fp-model=c,l,f,z,n,r,S,T -D__CPU__=tc39x -D__CPU_TC39X__ --core=tc1.6.2 --iso=99 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv4 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\arpa -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\net -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\sys -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\stdc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\apps -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\priv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Dp83825i -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Rtl8211f -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\UART -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Icu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmBc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\TimerWithTrigger -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\TPwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSpansion -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSt -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Dram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Sram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc\\Adc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce\\Crc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12\\IncrEnc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\In -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Trig -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hspdm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hspdm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Driver -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiMaster -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiSlave -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Emmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Sd -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Spu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Spu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\UART -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv4 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\arpa -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\net -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\sys -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\stdc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\apps -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\priv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Dp83825i -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -g2 --make-target=0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6\\nd6.o -t4 --language=-gcc,-volatile,+strings,-kanji --default-near-size=8 -O2 --default-a1-size=0 --default-a0-size=0 --source --align=0 --compact-max-size=200 --switch=auto --error-limit=42 -o 0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6\\nd6.src ..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6\\nd6.c"
	.compiler_name		"ctc"
	;source	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6\\nd6.c'

	
$TC162
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	733
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6\\nd6.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\Debug\\',0,12,1
	.word	.L5
	.byte	2
	.byte	'int',0,4,5,3
	.word	170
	.byte	4
	.byte	'__c11_atomic_thread_fence',0,1,1,1,1,5
	.word	177
	.byte	0,2
	.byte	'unsigned int',0,4,7,6
	.word	219
	.byte	7
	.word	219
	.byte	8
	.byte	'__cmpswapw',0
	.word	235
	.byte	1,1,1,1,9
	.byte	'p',0
	.word	240
	.byte	9
	.byte	'value',0
	.word	219
	.byte	9
	.byte	'compare',0
	.word	219
	.byte	0,2
	.byte	'short int',0,2,5,10
	.byte	'__wchar_t',0,1,1,1
	.word	297
	.byte	10
	.byte	'__size_t',0,1,1,1
	.word	219
	.byte	10
	.byte	'__ptrdiff_t',0,1,1,1
	.word	170
	.byte	11,1,7
	.word	365
	.byte	10
	.byte	'__codeptr',0,1,1,1
	.word	367
	.byte	10
	.byte	'__intptr_t',0,1,1,1
	.word	170
	.byte	10
	.byte	'__uintptr_t',0,1,1,1
	.word	219
	.byte	2
	.byte	'unsigned char',0,1,8,10
	.byte	'uint8',0,2,108,29
	.word	429
	.byte	2
	.byte	'unsigned short int',0,2,7,10
	.byte	'uint16',0,2,112,29
	.word	460
	.byte	2
	.byte	'unsigned long int',0,4,7,10
	.byte	'uint32',0,2,116,29
	.word	497
	.byte	2
	.byte	'char',0,1,6,10
	.byte	'sint8',0,2,125,29
	.word	533
	.byte	10
	.byte	'sint16',0,2,129,1,29
	.word	297
	.byte	2
	.byte	'long int',0,4,5,10
	.byte	'sint32',0,2,134,1,29
	.word	571
	.byte	2
	.byte	'long long int',0,8,5,10
	.byte	'sint64',0,2,141,1,29
	.word	599
	.byte	2
	.byte	'float',0,4,4,10
	.byte	'float32',0,2,170,1,29
	.word	632
	.byte	12
	.byte	'void',0,7
	.word	658
	.byte	10
	.byte	'pvoid',0,3,54,28
	.word	664
	.byte	10
	.byte	'Ifx_TickTime',0,3,76,28
	.word	599
	.byte	10
	.byte	'u32_t',0,4,87,16
	.word	497
	.byte	10
	.byte	'intmax_t',0,5,198,2,41
	.word	599
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,38,0,73,19,0,0,4,46,1,3,8,54
	.byte	15,39,12,63,12,60,12,0,0,5,5,0,73,19,0,0,6,53,0,73,19,0,0,7,15,0,73,19,0,0,8,46,1,3,8,73,19,54,15,39,12
	.byte	63,12,60,12,0,0,9,5,0,3,8,73,19,0,0,10,22,0,3,8,58,15,59,15,57,15,73,19,0,0,11,21,0,54,15,0,0,12,59,0
	.byte	3,8,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L7-.L6
.L6:
	.half	3
	.word	.L9-.L8
.L8:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch',0
	.byte	'D:\\App\\Tasking6_3_Install\\ctc\\include\\',0,0
	.byte	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6\\nd6.c',0,0,0,0
	.byte	'Platform_Types.h',0,1,0,0
	.byte	'Ifx_Types.h',0,1,0,0
	.byte	'cc.h',0,2,0,0
	.byte	'stdint.h',0,3,0,0,0
.L9:
.L7:

; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     1  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     2   * @file
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     3   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     4   * Neighbor discovery and stateless address autoconfiguration for IPv6.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     5   * Aims to be compliant with RFC 4861 (Neighbor discovery) and RFC 4862
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     6   * (Address autoconfiguration).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     7   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     8  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	     9  /*
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    10   * Copyright (c) 2010 Inico Technologies Ltd.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    11   * All rights reserved.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    12   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    13   * Redistribution and use in source and binary forms, with or without modification,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    14   * are permitted provided that the following conditions are met:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    15   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    16   * 1. Redistributions of source code must retain the above copyright notice,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    17   *    this list of conditions and the following disclaimer.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    18   * 2. Redistributions in binary form must reproduce the above copyright notice,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    19   *    this list of conditions and the following disclaimer in the documentation
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    20   *    and/or other materials provided with the distribution.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    21   * 3. The name of the author may not be used to endorse or promote products
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    22   *    derived from this software without specific prior written permission.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    23   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    24   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    25   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    26   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    27   * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    28   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    29   * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    30   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    31   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    32   * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    33   * OF SUCH DAMAGE.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    34   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    35   * This file is part of the lwIP TCP/IP stack.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    36   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    37   * Author: Ivan Delamer <delamer@inicotech.com>
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    38   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    39   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    40   * Please coordinate changes and requests with Ivan Delamer
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    41   * <delamer@inicotech.com>
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    42   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    43  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    44  #include "lwip/opt.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    45  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    46  #if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    47  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    48  #include "lwip/nd6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    49  #include "lwip/priv/nd6_priv.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    50  #include "lwip/prot/nd6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    51  #include "lwip/prot/icmp6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    52  #include "lwip/pbuf.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    53  #include "lwip/mem.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    54  #include "lwip/memp.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    55  #include "lwip/ip6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    56  #include "lwip/ip6_addr.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    57  #include "lwip/inet_chksum.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    58  #include "lwip/netif.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    59  #include "lwip/icmp6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    60  #include "lwip/mld6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    61  #include "lwip/dhcp6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    62  #include "lwip/ip.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    63  #include "lwip/stats.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    64  #include "lwip/dns.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    65  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    66  #include <string.h>
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    67  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    68  #ifdef LWIP_HOOK_FILENAME
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    69  #include LWIP_HOOK_FILENAME
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    70  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    71  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    72  #if LWIP_IPV6_DUP_DETECT_ATTEMPTS > IP6_ADDR_TENTATIVE_COUNT_MASK
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    73  #error LWIP_IPV6_DUP_DETECT_ATTEMPTS > IP6_ADDR_TENTATIVE_COUNT_MASK
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    74  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    75  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    76  /* Router tables. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    77  struct nd6_neighbor_cache_entry neighbor_cache[LWIP_ND6_NUM_NEIGHBORS];
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    78  struct nd6_destination_cache_entry destination_cache[LWIP_ND6_NUM_DESTINATIONS];
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    79  struct nd6_prefix_list_entry prefix_list[LWIP_ND6_NUM_PREFIXES];
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    80  struct nd6_router_list_entry default_router_list[LWIP_ND6_NUM_ROUTERS];
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    81  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    82  /* Default values, can be updated by a RA message. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    83  u32_t reachable_time = LWIP_ND6_REACHABLE_TIME;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    84  u32_t retrans_timer = LWIP_ND6_RETRANS_TIMER; /* @todo implement this value in timer */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    85  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    86  /* Index for cache entries. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    87  static u8_t nd6_cached_neighbor_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    88  static netif_addr_idx_t nd6_cached_destination_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    89  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    90  /* Multicast address holder. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    91  static ip6_addr_t multicast_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    92  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    93  static u8_t nd6_tmr_rs_reduction;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    94  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    95  /* Static buffer to parse RA packet options */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    96  union ra_options {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    97    struct lladdr_option  lladdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    98    struct mtu_option     mtu;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	    99    struct prefix_option  prefix;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   100  #if LWIP_ND6_RDNSS_MAX_DNS_SERVERS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   101    struct rdnss_option   rdnss;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   102  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   103  };
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   104  static union ra_options nd6_ra_buffer;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   105  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   106  /* Forward declarations. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   107  static s8_t nd6_find_neighbor_cache_entry(const ip6_addr_t *ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   108  static s8_t nd6_new_neighbor_cache_entry(void);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   109  static void nd6_free_neighbor_cache_entry(s8_t i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   110  static s16_t nd6_find_destination_cache_entry(const ip6_addr_t *ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   111  static s16_t nd6_new_destination_cache_entry(void);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   112  static int nd6_is_prefix_in_netif(const ip6_addr_t *ip6addr, struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   113  static s8_t nd6_select_router(const ip6_addr_t *ip6addr, struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   114  static s8_t nd6_get_router(const ip6_addr_t *router_addr, struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   115  static s8_t nd6_new_router(const ip6_addr_t *router_addr, struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   116  static s8_t nd6_get_onlink_prefix(const ip6_addr_t *prefix, struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   117  static s8_t nd6_new_onlink_prefix(const ip6_addr_t *prefix, struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   118  static s8_t nd6_get_next_hop_entry(const ip6_addr_t *ip6addr, struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   119  static err_t nd6_queue_packet(s8_t neighbor_index, struct pbuf *q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   120  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   121  #define ND6_SEND_FLAG_MULTICAST_DEST 0x01
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   122  #define ND6_SEND_FLAG_ALLNODES_DEST 0x02
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   123  #define ND6_SEND_FLAG_ANY_SRC 0x04
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   124  static void nd6_send_ns(struct netif *netif, const ip6_addr_t *target_addr, u8_t flags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   125  static void nd6_send_na(struct netif *netif, const ip6_addr_t *target_addr, u8_t flags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   126  static void nd6_send_neighbor_cache_probe(struct nd6_neighbor_cache_entry *entry, u8_t flags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   127  #if LWIP_IPV6_SEND_ROUTER_SOLICIT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   128  static err_t nd6_send_rs(struct netif *netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   129  #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   130  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   131  #if LWIP_ND6_QUEUEING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   132  static void nd6_free_q(struct nd6_q_entry *q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   133  #else /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   134  #define nd6_free_q(q) pbuf_free(q)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   135  #endif /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   136  static void nd6_send_q(s8_t i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   137  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   138  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   139  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   140   * A local address has been determined to be a duplicate. Take the appropriate
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   141   * action(s) on the address and the interface as a whole.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   142   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   143   * @param netif the netif that owns the address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   144   * @param addr_idx the index of the address detected to be a duplicate
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   145   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   146  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   147  nd6_duplicate_addr_detected(struct netif *netif, s8_t addr_idx)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   148  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   149  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   150    /* Mark the address as duplicate, but leave its lifetimes alone. If this was
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   151     * a manually assigned address, it will remain in existence as duplicate, and
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   152     * as such be unusable for any practical purposes until manual intervention.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   153     * If this was an autogenerated address, the address will follow normal
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   154     * expiration rules, and thus disappear once its valid lifetime expires. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   155    netif_ip6_addr_set_state(netif, addr_idx, IP6_ADDR_DUPLICATED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   156  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   157  #if LWIP_IPV6_AUTOCONFIG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   158    /* If the affected address was the link-local address that we use to generate
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   159     * all other addresses, then we should not continue to use those derived
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   160     * addresses either, so mark them as duplicate as well. For autoconfig-only
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   161     * setups, this will make the interface effectively unusable, approaching the
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   162     * intention of RFC 4862 Sec. 5.4.5. @todo implement the full requirements */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   163    if (addr_idx == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   164      s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   165      for (i = 1; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   166        if (!ip6_addr_isinvalid(netif_ip6_addr_state(netif, i)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   167            !netif_ip6_addr_isstatic(netif, i)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   168          netif_ip6_addr_set_state(netif, i, IP6_ADDR_DUPLICATED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   169        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   170      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   171    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   172  #endif /* LWIP_IPV6_AUTOCONFIG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   173  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   174  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   175  #if LWIP_IPV6_AUTOCONFIG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   176  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   177   * We received a router advertisement that contains a prefix with the
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   178   * autoconfiguration flag set. Add or update an associated autogenerated
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   179   * address.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   180   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   181   * @param netif the netif on which the router advertisement arrived
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   182   * @param prefix_opt a pointer to the prefix option data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   183   * @param prefix_addr an aligned copy of the prefix address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   184   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   185  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   186  nd6_process_autoconfig_prefix(struct netif *netif,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   187    struct prefix_option *prefix_opt, const ip6_addr_t *prefix_addr)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   188  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   189    ip6_addr_t ip6addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   190    u32_t valid_life, pref_life;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   191    u8_t addr_state;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   192    s8_t i, free_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   193  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   194    /* The caller already checks RFC 4862 Sec. 5.5.3 points (a) and (b). We do
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   195     * the rest, starting with checks for (c) and (d) here. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   196    valid_life = lwip_htonl(prefix_opt->valid_lifetime);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   197    pref_life = lwip_htonl(prefix_opt->preferred_lifetime);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   198    if (pref_life > valid_life || prefix_opt->prefix_length != 64) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   199      return; /* silently ignore this prefix for autoconfiguration purposes */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   200    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   201  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   202    /* If an autogenerated address already exists for this prefix, update its
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   203     * lifetimes. An address is considered autogenerated if 1) it is not static
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   204     * (i.e., manually assigned), and 2) there is an advertised autoconfiguration
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   205     * prefix for it (the one we are processing here). This does not necessarily
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   206     * exclude the possibility that the address was actually assigned by, say,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   207     * DHCPv6. If that distinction becomes important in the future, more state
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   208     * must be kept. As explained elsewhere we also update lifetimes of tentative
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   209     * and duplicate addresses. Skip address slot 0 (the link-local address). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   210    for (i = 1; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   211      addr_state = netif_ip6_addr_state(netif, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   212      if (!ip6_addr_isinvalid(addr_state) && !netif_ip6_addr_isstatic(netif, i) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   213          ip6_addr_netcmp(prefix_addr, netif_ip6_addr(netif, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   214        /* Update the valid lifetime, as per RFC 4862 Sec. 5.5.3 point (e).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   215         * The valid lifetime will never drop to zero as a result of this. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   216        u32_t remaining_life = netif_ip6_addr_valid_life(netif, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   217        if (valid_life > ND6_2HRS || valid_life > remaining_life) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   218          netif_ip6_addr_set_valid_life(netif, i, valid_life);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   219        } else if (remaining_life > ND6_2HRS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   220          netif_ip6_addr_set_valid_life(netif, i, ND6_2HRS);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   221        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   222        LWIP_ASSERT("bad valid lifetime", !netif_ip6_addr_isstatic(netif, i));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   223        /* Update the preferred lifetime. No bounds checks are needed here. In
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   224         * rare cases the advertisement may un-deprecate the address, though.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   225         * Deprecation is left to the timer code where it is handled anyway. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   226        if (pref_life > 0 && addr_state == IP6_ADDR_DEPRECATED) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   227          netif_ip6_addr_set_state(netif, i, IP6_ADDR_PREFERRED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   228        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   229        netif_ip6_addr_set_pref_life(netif, i, pref_life);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   230        return; /* there should be at most one matching address */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   231      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   232    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   233  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   234    /* No autogenerated address exists for this prefix yet. See if we can add a
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   235     * new one. However, if IPv6 autoconfiguration is administratively disabled,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   236     * do not generate new addresses, but do keep updating lifetimes for existing
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   237     * addresses. Also, when adding new addresses, we must protect explicitly
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   238     * against a valid lifetime of zero, because again, we use that as a special
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   239     * value. The generated address would otherwise expire immediately anyway.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   240     * Finally, the original link-local address must be usable at all. We start
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   241     * creating addresses even if the link-local address is still in tentative
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   242     * state though, and deal with the fallout of that upon DAD collision. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   243    addr_state = netif_ip6_addr_state(netif, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   244    if (!netif->ip6_autoconfig_enabled || valid_life == IP6_ADDR_LIFE_STATIC ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   245        ip6_addr_isinvalid(addr_state) || ip6_addr_isduplicated(addr_state)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   246      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   247    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   248  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   249    /* Construct the new address that we intend to use, and then see if that
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   250     * address really does not exist. It might have been added manually, after
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   251     * all. As a side effect, find a free slot. Note that we cannot use
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   252     * netif_add_ip6_address() here, as it would return ERR_OK if the address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   253     * already did exist, resulting in that address being given lifetimes. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   254    IP6_ADDR(&ip6addr, prefix_addr->addr[0], prefix_addr->addr[1],
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   255      netif_ip6_addr(netif, 0)->addr[2], netif_ip6_addr(netif, 0)->addr[3]);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   256    ip6_addr_assign_zone(&ip6addr, IP6_UNICAST, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   257  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   258    free_idx = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   259    for (i = 1; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   260      if (!ip6_addr_isinvalid(netif_ip6_addr_state(netif, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   261        if (ip6_addr_cmp(&ip6addr, netif_ip6_addr(netif, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   262          return; /* formed address already exists */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   263        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   264      } else if (free_idx == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   265        free_idx = i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   266      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   267    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   268    if (free_idx == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   269      return; /* no address slots available, try again on next advertisement */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   270    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   271  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   272    /* Assign the new address to the interface. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   273    ip_addr_copy_from_ip6(netif->ip6_addr[free_idx], ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   274    netif_ip6_addr_set_valid_life(netif, free_idx, valid_life);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   275    netif_ip6_addr_set_pref_life(netif, free_idx, pref_life);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   276    netif_ip6_addr_set_state(netif, free_idx, IP6_ADDR_TENTATIVE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   277  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   278  #endif /* LWIP_IPV6_AUTOCONFIG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   279  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   280  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   281   * Process an incoming neighbor discovery message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   282   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   283   * @param p the nd packet, p->payload pointing to the icmpv6 header
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   284   * @param inp the netif on which this packet was received
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   285   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   286  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   287  nd6_input(struct pbuf *p, struct netif *inp)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   288  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   289    u8_t msg_type;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   290    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   291    s16_t dest_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   292  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   293    ND6_STATS_INC(nd6.recv);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   294  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   295    msg_type = *((u8_t *)p->payload);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   296    switch (msg_type) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   297    case ICMP6_TYPE_NA: /* Neighbor Advertisement. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   298    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   299      struct na_header *na_hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   300      struct lladdr_option *lladdr_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   301      ip6_addr_t target_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   302  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   303      /* Check that na header fits in packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   304      if (p->len < (sizeof(struct na_header))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   305        /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   306        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   307        ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   308        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   309        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   310      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   311  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   312      na_hdr = (struct na_header *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   313  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   314      /* Create an aligned, zoned copy of the target address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   315      ip6_addr_copy_from_packed(target_address, na_hdr->target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   316      ip6_addr_assign_zone(&target_address, IP6_UNICAST, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   317  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   318      /* Check a subset of the other RFC 4861 Sec. 7.1.2 requirements. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   319      if (IP6H_HOPLIM(ip6_current_header()) != ND6_HOPLIM || na_hdr->code != 0 ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   320          ip6_addr_ismulticast(&target_address)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   321        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   322        ND6_STATS_INC(nd6.proterr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   323        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   324        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   325      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   326  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   327      /* @todo RFC MUST: if IP destination is multicast, Solicited flag is zero */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   328      /* @todo RFC MUST: all included options have a length greater than zero */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   329  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   330      /* Unsolicited NA?*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   331      if (ip6_addr_ismulticast(ip6_current_dest_addr())) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   332        /* This is an unsolicited NA.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   333         * link-layer changed?
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   334         * part of DAD mechanism? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   335  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   336  #if LWIP_IPV6_DUP_DETECT_ATTEMPTS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   337        /* If the target address matches this netif, it is a DAD response. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   338        for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   339          if (!ip6_addr_isinvalid(netif_ip6_addr_state(inp, i)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   340              !ip6_addr_isduplicated(netif_ip6_addr_state(inp, i)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   341              ip6_addr_cmp(&target_address, netif_ip6_addr(inp, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   342            /* We are using a duplicate address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   343            nd6_duplicate_addr_detected(inp, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   344  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   345            pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   346            return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   347          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   348        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   349  #endif /* LWIP_IPV6_DUP_DETECT_ATTEMPTS */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   350  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   351        /* Check that link-layer address option also fits in packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   352        if (p->len < (sizeof(struct na_header) + 2)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   353          /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   354          pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   355          ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   356          ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   357          return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   358        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   359  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   360        lladdr_opt = (struct lladdr_option *)((u8_t*)p->payload + sizeof(struct na_header));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   361  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   362        if (p->len < (sizeof(struct na_header) + (lladdr_opt->length << 3))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   363          /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   364          pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   365          ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   366          ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   367          return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   368        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   369  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   370        /* This is an unsolicited NA, most likely there was a LLADDR change. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   371        i = nd6_find_neighbor_cache_entry(&target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   372        if (i >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   373          if (na_hdr->flags & ND6_FLAG_OVERRIDE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   374            MEMCPY(neighbor_cache[i].lladdr, lladdr_opt->addr, inp->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   375          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   376        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   377      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   378        /* This is a solicited NA.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   379         * neighbor address resolution response?
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   380         * neighbor unreachability detection response? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   381  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   382        /* Find the cache entry corresponding to this na. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   383        i = nd6_find_neighbor_cache_entry(&target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   384        if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   385          /* We no longer care about this target address. drop it. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   386          pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   387          return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   388        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   389  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   390        /* Update cache entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   391        if ((na_hdr->flags & ND6_FLAG_OVERRIDE) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   392            (neighbor_cache[i].state == ND6_INCOMPLETE)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   393          /* Check that link-layer address option also fits in packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   394          if (p->len < (sizeof(struct na_header) + 2)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   395            /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   396            pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   397            ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   398            ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   399            return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   400          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   401  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   402          lladdr_opt = (struct lladdr_option *)((u8_t*)p->payload + sizeof(struct na_header));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   403  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   404          if (p->len < (sizeof(struct na_header) + (lladdr_opt->length << 3))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   405            /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   406            pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   407            ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   408            ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   409            return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   410          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   411  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   412          MEMCPY(neighbor_cache[i].lladdr, lladdr_opt->addr, inp->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   413        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   414  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   415        neighbor_cache[i].netif = inp;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   416        neighbor_cache[i].state = ND6_REACHABLE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   417        neighbor_cache[i].counter.reachable_time = reachable_time;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   418  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   419        /* Send queued packets, if any. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   420        if (neighbor_cache[i].q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   421          nd6_send_q(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   422        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   423      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   424  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   425      break; /* ICMP6_TYPE_NA */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   426    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   427    case ICMP6_TYPE_NS: /* Neighbor solicitation. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   428    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   429      struct ns_header *ns_hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   430      struct lladdr_option *lladdr_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   431      ip6_addr_t target_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   432      u8_t accepted;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   433  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   434      /* Check that ns header fits in packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   435      if (p->len < sizeof(struct ns_header)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   436        /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   437        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   438        ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   439        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   440        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   441      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   442  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   443      ns_hdr = (struct ns_header *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   444  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   445      /* Create an aligned, zoned copy of the target address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   446      ip6_addr_copy_from_packed(target_address, ns_hdr->target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   447      ip6_addr_assign_zone(&target_address, IP6_UNICAST, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   448  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   449      /* Check a subset of the other RFC 4861 Sec. 7.1.1 requirements. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   450      if (IP6H_HOPLIM(ip6_current_header()) != ND6_HOPLIM || ns_hdr->code != 0 ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   451         ip6_addr_ismulticast(&target_address)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   452        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   453        ND6_STATS_INC(nd6.proterr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   454        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   455        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   456      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   457  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   458      /* @todo RFC MUST: all included options have a length greater than zero */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   459      /* @todo RFC MUST: if IP source is 'any', destination is solicited-node multicast address */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   460      /* @todo RFC MUST: if IP source is 'any', there is no source LL address option */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   461  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   462      /* Check if there is a link-layer address provided. Only point to it if in this buffer. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   463      if (p->len >= (sizeof(struct ns_header) + 2)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   464        lladdr_opt = (struct lladdr_option *)((u8_t*)p->payload + sizeof(struct ns_header));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   465        if (p->len < (sizeof(struct ns_header) + (lladdr_opt->length << 3))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   466          lladdr_opt = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   467        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   468      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   469        lladdr_opt = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   470      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   471  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   472      /* Check if the target address is configured on the receiving netif. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   473      accepted = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   474      for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; ++i) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   475        if ((ip6_addr_isvalid(netif_ip6_addr_state(inp, i)) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   476             (ip6_addr_istentative(netif_ip6_addr_state(inp, i)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   477              ip6_addr_isany(ip6_current_src_addr()))) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   478            ip6_addr_cmp(&target_address, netif_ip6_addr(inp, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   479          accepted = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   480          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   481        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   482      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   483  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   484      /* NS not for us? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   485      if (!accepted) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   486        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   487        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   488      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   489  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   490      /* Check for ANY address in src (DAD algorithm). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   491      if (ip6_addr_isany(ip6_current_src_addr())) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   492        /* Sender is validating this address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   493        for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; ++i) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   494          if (!ip6_addr_isinvalid(netif_ip6_addr_state(inp, i)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   495              ip6_addr_cmp(&target_address, netif_ip6_addr(inp, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   496            /* Send a NA back so that the sender does not use this address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   497            nd6_send_na(inp, netif_ip6_addr(inp, i), ND6_FLAG_OVERRIDE | ND6_SEND_FLAG_ALLNODES_DEST);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   498            if (ip6_addr_istentative(netif_ip6_addr_state(inp, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   499              /* We shouldn't use this address either. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   500              nd6_duplicate_addr_detected(inp, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   501            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   502          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   503        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   504      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   505        /* Sender is trying to resolve our address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   506        /* Verify that they included their own link-layer address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   507        if (lladdr_opt == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   508          /* Not a valid message. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   509          pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   510          ND6_STATS_INC(nd6.proterr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   511          ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   512          return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   513        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   514  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   515        i = nd6_find_neighbor_cache_entry(ip6_current_src_addr());
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   516        if (i>= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   517          /* We already have a record for the solicitor. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   518          if (neighbor_cache[i].state == ND6_INCOMPLETE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   519            neighbor_cache[i].netif = inp;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   520            MEMCPY(neighbor_cache[i].lladdr, lladdr_opt->addr, inp->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   521  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   522            /* Delay probe in case we get confirmation of reachability from upper layer (TCP). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   523            neighbor_cache[i].state = ND6_DELAY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   524            neighbor_cache[i].counter.delay_time = LWIP_ND6_DELAY_FIRST_PROBE_TIME / ND6_TMR_INTERVAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   525          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   526        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   527          /* Add their IPv6 address and link-layer address to neighbor cache.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   528           * We will need it at least to send a unicast NA message, but most
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   529           * likely we will also be communicating with this node soon. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   530          i = nd6_new_neighbor_cache_entry();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   531          if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   532            /* We couldn't assign a cache entry for this neighbor.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   533             * we won't be able to reply. drop it. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   534            pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   535            ND6_STATS_INC(nd6.memerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   536            return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   537          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   538          neighbor_cache[i].netif = inp;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   539          MEMCPY(neighbor_cache[i].lladdr, lladdr_opt->addr, inp->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   540          ip6_addr_set(&(neighbor_cache[i].next_hop_address), ip6_current_src_addr());
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   541  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   542          /* Receiving a message does not prove reachability: only in one direction.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   543           * Delay probe in case we get confirmation of reachability from upper layer (TCP). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   544          neighbor_cache[i].state = ND6_DELAY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   545          neighbor_cache[i].counter.delay_time = LWIP_ND6_DELAY_FIRST_PROBE_TIME / ND6_TMR_INTERVAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   546        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   547  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   548        /* Send back a NA for us. Allocate the reply pbuf. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   549        nd6_send_na(inp, &target_address, ND6_FLAG_SOLICITED | ND6_FLAG_OVERRIDE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   550      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   551  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   552      break; /* ICMP6_TYPE_NS */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   553    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   554    case ICMP6_TYPE_RA: /* Router Advertisement. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   555    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   556      struct ra_header *ra_hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   557      u8_t *buffer; /* Used to copy options. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   558      u16_t offset;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   559  #if LWIP_ND6_RDNSS_MAX_DNS_SERVERS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   560      /* There can be multiple RDNSS options per RA */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   561      u8_t rdnss_server_idx = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   562  #endif /* LWIP_ND6_RDNSS_MAX_DNS_SERVERS */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   563  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   564      /* Check that RA header fits in packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   565      if (p->len < sizeof(struct ra_header)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   566        /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   567        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   568        ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   569        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   570        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   571      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   572  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   573      ra_hdr = (struct ra_header *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   574  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   575      /* Check a subset of the other RFC 4861 Sec. 6.1.2 requirements. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   576      if (!ip6_addr_islinklocal(ip6_current_src_addr()) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   577          IP6H_HOPLIM(ip6_current_header()) != ND6_HOPLIM || ra_hdr->code != 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   578        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   579        ND6_STATS_INC(nd6.proterr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   580        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   581        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   582      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   583  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   584      /* @todo RFC MUST: all included options have a length greater than zero */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   585  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   586      /* If we are sending RS messages, stop. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   587  #if LWIP_IPV6_SEND_ROUTER_SOLICIT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   588      /* ensure at least one solicitation is sent (see RFC 4861, ch. 6.3.7) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   589      if ((inp->rs_count < LWIP_ND6_MAX_MULTICAST_SOLICIT) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   590          (nd6_send_rs(inp) == ERR_OK)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   591        inp->rs_count = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   592      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   593        inp->rs_count = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   594      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   595  #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   596  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   597      /* Get the matching default router entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   598      i = nd6_get_router(ip6_current_src_addr(), inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   599      if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   600        /* Create a new router entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   601        i = nd6_new_router(ip6_current_src_addr(), inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   602      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   603  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   604      if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   605        /* Could not create a new router entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   606        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   607        ND6_STATS_INC(nd6.memerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   608        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   609      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   610  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   611      /* Re-set invalidation timer. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   612      default_router_list[i].invalidation_timer = lwip_htons(ra_hdr->router_lifetime);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   613  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   614      /* Re-set default timer values. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   615  #if LWIP_ND6_ALLOW_RA_UPDATES
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   616      if (ra_hdr->retrans_timer > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   617        retrans_timer = lwip_htonl(ra_hdr->retrans_timer);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   618      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   619      if (ra_hdr->reachable_time > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   620        reachable_time = lwip_htonl(ra_hdr->reachable_time);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   621      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   622  #endif /* LWIP_ND6_ALLOW_RA_UPDATES */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   623  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   624      /* @todo set default hop limit... */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   625      /* ra_hdr->current_hop_limit;*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   626  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   627      /* Update flags in local entry (incl. preference). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   628      default_router_list[i].flags = ra_hdr->flags;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   629  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   630  #if LWIP_IPV6_DHCP6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   631      /* Trigger DHCPv6 if enabled */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   632      dhcp6_nd6_ra_trigger(inp, ra_hdr->flags & ND6_RA_FLAG_MANAGED_ADDR_CONFIG,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   633        ra_hdr->flags & ND6_RA_FLAG_OTHER_CONFIG);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   634  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   635  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   636      /* Offset to options. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   637      offset = sizeof(struct ra_header);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   638  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   639      /* Process each option. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   640      while ((p->tot_len - offset) >= 2) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   641        u8_t option_type;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   642        u16_t option_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   643        int option_len8 = pbuf_try_get_at(p, offset + 1);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   644        if (option_len8 <= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   645          /* read beyond end or zero length */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   646          goto lenerr_drop_free_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   647        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   648        option_len = ((u8_t)option_len8) << 3;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   649        if (option_len > p->tot_len - offset) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   650          /* short packet (option does not fit in) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   651          goto lenerr_drop_free_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   652        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   653        if (p->len == p->tot_len) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   654          /* no need to copy from contiguous pbuf */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   655          buffer = &((u8_t*)p->payload)[offset];
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   656        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   657          /* check if this option fits into our buffer */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   658          if (option_len > sizeof(nd6_ra_buffer)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   659            option_type = pbuf_get_at(p, offset);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   660            /* invalid option length */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   661            if (option_type != ND6_OPTION_TYPE_RDNSS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   662              goto lenerr_drop_free_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   663            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   664            /* we allow RDNSS option to be longer - we'll just drop some servers */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   665            option_len = sizeof(nd6_ra_buffer);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   666          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   667          buffer = (u8_t*)&nd6_ra_buffer;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   668          option_len = pbuf_copy_partial(p, &nd6_ra_buffer, option_len, offset);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   669        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   670        option_type = buffer[0];
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   671        switch (option_type) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   672        case ND6_OPTION_TYPE_SOURCE_LLADDR:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   673        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   674          struct lladdr_option *lladdr_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   675          if (option_len < sizeof(struct lladdr_option)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   676            goto lenerr_drop_free_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   677          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   678          lladdr_opt = (struct lladdr_option *)buffer;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   679          if ((default_router_list[i].neighbor_entry != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   680              (default_router_list[i].neighbor_entry->state == ND6_INCOMPLETE)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   681            SMEMCPY(default_router_list[i].neighbor_entry->lladdr, lladdr_opt->addr, inp->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   682            default_router_list[i].neighbor_entry->state = ND6_REACHABLE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   683            default_router_list[i].neighbor_entry->counter.reachable_time = reachable_time;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   684          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   685          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   686        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   687        case ND6_OPTION_TYPE_MTU:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   688        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   689          struct mtu_option *mtu_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   690          u32_t mtu32;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   691          if (option_len < sizeof(struct mtu_option)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   692            goto lenerr_drop_free_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   693          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   694          mtu_opt = (struct mtu_option *)buffer;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   695          mtu32 = lwip_htonl(mtu_opt->mtu);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   696          if ((mtu32 >= 1280) && (mtu32 <= 0xffff)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   697  #if LWIP_ND6_ALLOW_RA_UPDATES
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   698            if (inp->mtu) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   699              /* don't set the mtu for IPv6 higher than the netif driver supports */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   700              inp->mtu6 = LWIP_MIN(inp->mtu, (u16_t)mtu32);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   701            } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   702              inp->mtu6 = (u16_t)mtu32;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   703            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   704  #endif /* LWIP_ND6_ALLOW_RA_UPDATES */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   705          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   706          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   707        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   708        case ND6_OPTION_TYPE_PREFIX_INFO:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   709        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   710          struct prefix_option *prefix_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   711          ip6_addr_t prefix_addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   712          if (option_len < sizeof(struct prefix_option)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   713            goto lenerr_drop_free_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   714          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   715  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   716          prefix_opt = (struct prefix_option *)buffer;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   717  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   718          /* Get a memory-aligned copy of the prefix. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   719          ip6_addr_copy_from_packed(prefix_addr, prefix_opt->prefix);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   720          ip6_addr_assign_zone(&prefix_addr, IP6_UNICAST, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   721  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   722          if (!ip6_addr_islinklocal(&prefix_addr)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   723            if ((prefix_opt->flags & ND6_PREFIX_FLAG_ON_LINK) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   724                (prefix_opt->prefix_length == 64)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   725              /* Add to on-link prefix list. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   726              u32_t valid_life;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   727              s8_t prefix;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   728  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   729              valid_life = lwip_htonl(prefix_opt->valid_lifetime);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   730  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   731              /* find cache entry for this prefix. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   732              prefix = nd6_get_onlink_prefix(&prefix_addr, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   733              if (prefix < 0 && valid_life > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   734                /* Create a new cache entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   735                prefix = nd6_new_onlink_prefix(&prefix_addr, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   736              }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   737              if (prefix >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   738                prefix_list[prefix].invalidation_timer = valid_life;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   739              }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   740            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   741  #if LWIP_IPV6_AUTOCONFIG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   742            if (prefix_opt->flags & ND6_PREFIX_FLAG_AUTONOMOUS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   743              /* Perform processing for autoconfiguration. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   744              nd6_process_autoconfig_prefix(inp, prefix_opt, &prefix_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   745            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   746  #endif /* LWIP_IPV6_AUTOCONFIG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   747          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   748  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   749          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   750        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   751        case ND6_OPTION_TYPE_ROUTE_INFO:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   752          /* @todo implement preferred routes.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   753          struct route_option * route_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   754          route_opt = (struct route_option *)buffer;*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   755  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   756          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   757  #if LWIP_ND6_RDNSS_MAX_DNS_SERVERS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   758        case ND6_OPTION_TYPE_RDNSS:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   759        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   760          u8_t num, n;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   761          u16_t copy_offset = offset + SIZEOF_RDNSS_OPTION_BASE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   762          struct rdnss_option * rdnss_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   763          if (option_len < SIZEOF_RDNSS_OPTION_BASE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   764            goto lenerr_drop_free_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   765          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   766  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   767          rdnss_opt = (struct rdnss_option *)buffer;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   768          num = (rdnss_opt->length - 1) / 2;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   769          for (n = 0; (rdnss_server_idx < DNS_MAX_SERVERS) && (n < num); n++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   770            ip_addr_t rdnss_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   771  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   772            /* Copy directly from pbuf to get an aligned, zoned copy of the prefix. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   773            if (pbuf_copy_partial(p, &rdnss_address, sizeof(ip6_addr_p_t), copy_offset) == sizeof(ip6_addr_p_t)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   774              IP_SET_TYPE_VAL(rdnss_address, IPADDR_TYPE_V6);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   775              ip6_addr_assign_zone(ip_2_ip6(&rdnss_address), IP6_UNKNOWN, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   776  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   777              if (htonl(rdnss_opt->lifetime) > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   778                /* TODO implement Lifetime > 0 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   779                dns_setserver(rdnss_server_idx++, &rdnss_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   780              } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   781                /* TODO implement DNS removal in dns.c */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   782                u8_t s;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   783                for (s = 0; s < DNS_MAX_SERVERS; s++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   784                  const ip_addr_t *addr = dns_getserver(s);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   785                  if(ip_addr_cmp(addr, &rdnss_address)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   786                    dns_setserver(s, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   787                  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   788                }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   789              }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   790            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   791          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   792          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   793        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   794  #endif /* LWIP_ND6_RDNSS_MAX_DNS_SERVERS */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   795        default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   796          /* Unrecognized option, abort. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   797          ND6_STATS_INC(nd6.proterr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   798          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   799        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   800        /* option length is checked earlier to be non-zero to make sure loop ends */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   801        offset += 8 * (u8_t)option_len8;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   802      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   803  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   804      break; /* ICMP6_TYPE_RA */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   805    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   806    case ICMP6_TYPE_RD: /* Redirect */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   807    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   808      struct redirect_header *redir_hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   809      struct lladdr_option *lladdr_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   810      ip6_addr_t destination_address, target_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   811  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   812      /* Check that Redir header fits in packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   813      if (p->len < sizeof(struct redirect_header)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   814        /* @todo debug message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   815        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   816        ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   817        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   818        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   819      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   820  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   821      redir_hdr = (struct redirect_header *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   822  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   823      /* Create an aligned, zoned copy of the destination address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   824      ip6_addr_copy_from_packed(destination_address, redir_hdr->destination_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   825      ip6_addr_assign_zone(&destination_address, IP6_UNICAST, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   826  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   827      /* Check a subset of the other RFC 4861 Sec. 8.1 requirements. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   828      if (!ip6_addr_islinklocal(ip6_current_src_addr()) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   829          IP6H_HOPLIM(ip6_current_header()) != ND6_HOPLIM ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   830          redir_hdr->code != 0 || ip6_addr_ismulticast(&destination_address)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   831        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   832        ND6_STATS_INC(nd6.proterr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   833        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   834        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   835      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   836  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   837      /* @todo RFC MUST: IP source address equals first-hop router for destination_address */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   838      /* @todo RFC MUST: ICMP target address is either link-local address or same as destination_address */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   839      /* @todo RFC MUST: all included options have a length greater than zero */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   840  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   841      if (p->len >= (sizeof(struct redirect_header) + 2)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   842        lladdr_opt = (struct lladdr_option *)((u8_t*)p->payload + sizeof(struct redirect_header));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   843        if (p->len < (sizeof(struct redirect_header) + (lladdr_opt->length << 3))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   844          lladdr_opt = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   845        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   846      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   847        lladdr_opt = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   848      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   849  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   850      /* Find dest address in cache */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   851      dest_idx = nd6_find_destination_cache_entry(&destination_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   852      if (dest_idx < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   853        /* Destination not in cache, drop packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   854        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   855        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   856      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   857  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   858      /* Create an aligned, zoned copy of the target address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   859      ip6_addr_copy_from_packed(target_address, redir_hdr->target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   860      ip6_addr_assign_zone(&target_address, IP6_UNICAST, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   861  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   862      /* Set the new target address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   863      ip6_addr_copy(destination_cache[dest_idx].next_hop_addr, target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   864  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   865      /* If Link-layer address of other router is given, try to add to neighbor cache. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   866      if (lladdr_opt != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   867        if (lladdr_opt->type == ND6_OPTION_TYPE_TARGET_LLADDR) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   868          i = nd6_find_neighbor_cache_entry(&target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   869          if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   870            i = nd6_new_neighbor_cache_entry();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   871            if (i >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   872              neighbor_cache[i].netif = inp;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   873              MEMCPY(neighbor_cache[i].lladdr, lladdr_opt->addr, inp->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   874              ip6_addr_copy(neighbor_cache[i].next_hop_address, target_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   875  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   876              /* Receiving a message does not prove reachability: only in one direction.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   877               * Delay probe in case we get confirmation of reachability from upper layer (TCP). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   878              neighbor_cache[i].state = ND6_DELAY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   879              neighbor_cache[i].counter.delay_time = LWIP_ND6_DELAY_FIRST_PROBE_TIME / ND6_TMR_INTERVAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   880            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   881          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   882          if (i >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   883            if (neighbor_cache[i].state == ND6_INCOMPLETE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   884              MEMCPY(neighbor_cache[i].lladdr, lladdr_opt->addr, inp->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   885              /* Receiving a message does not prove reachability: only in one direction.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   886               * Delay probe in case we get confirmation of reachability from upper layer (TCP). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   887              neighbor_cache[i].state = ND6_DELAY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   888              neighbor_cache[i].counter.delay_time = LWIP_ND6_DELAY_FIRST_PROBE_TIME / ND6_TMR_INTERVAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   889            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   890          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   891        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   892      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   893      break; /* ICMP6_TYPE_RD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   894    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   895    case ICMP6_TYPE_PTB: /* Packet too big */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   896    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   897      struct icmp6_hdr *icmp6hdr; /* Packet too big message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   898      struct ip6_hdr *ip6hdr; /* IPv6 header of the packet which caused the error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   899      u32_t pmtu;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   900      ip6_addr_t destination_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   901  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   902      /* Check that ICMPv6 header + IPv6 header fit in payload */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   903      if (p->len < (sizeof(struct icmp6_hdr) + IP6_HLEN)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   904        /* drop short packets */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   905        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   906        ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   907        ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   908        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   909      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   910  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   911      icmp6hdr = (struct icmp6_hdr *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   912      ip6hdr = (struct ip6_hdr *)((u8_t*)p->payload + sizeof(struct icmp6_hdr));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   913  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   914      /* Create an aligned, zoned copy of the destination address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   915      ip6_addr_copy_from_packed(destination_address, ip6hdr->dest);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   916      ip6_addr_assign_zone(&destination_address, IP6_UNKNOWN, inp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   917  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   918      /* Look for entry in destination cache. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   919      dest_idx = nd6_find_destination_cache_entry(&destination_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   920      if (dest_idx < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   921        /* Destination not in cache, drop packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   922        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   923        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   924      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   925  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   926      /* Change the Path MTU. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   927      pmtu = lwip_htonl(icmp6hdr->data);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   928      destination_cache[dest_idx].pmtu = (u16_t)LWIP_MIN(pmtu, 0xFFFF);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   929  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   930      break; /* ICMP6_TYPE_PTB */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   931    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   932  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   933    default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   934      ND6_STATS_INC(nd6.proterr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   935      ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   936      break; /* default */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   937    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   938  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   939    pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   940    return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   941  lenerr_drop_free_return:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   942    ND6_STATS_INC(nd6.lenerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   943    ND6_STATS_INC(nd6.drop);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   944    pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   945  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   946  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   947  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   948  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   949   * Periodic timer for Neighbor discovery functions:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   950   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   951   * - Update neighbor reachability states
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   952   * - Update destination cache entries age
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   953   * - Update invalidation timers of default routers and on-link prefixes
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   954   * - Update lifetimes of our addresses
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   955   * - Perform duplicate address detection (DAD) for our addresses
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   956   * - Send router solicitations
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   957   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   958  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   959  nd6_tmr(void)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   960  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   961    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   962    struct netif *netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   963  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   964    /* Process neighbor entries. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   965    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   966      switch (neighbor_cache[i].state) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   967      case ND6_INCOMPLETE:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   968        if ((neighbor_cache[i].counter.probes_sent >= LWIP_ND6_MAX_MULTICAST_SOLICIT) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   969            (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   970          /* Retries exceeded. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   971          nd6_free_neighbor_cache_entry(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   972        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   973          /* Send a NS for this entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   974          neighbor_cache[i].counter.probes_sent++;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   975          nd6_send_neighbor_cache_probe(&neighbor_cache[i], ND6_SEND_FLAG_MULTICAST_DEST);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   976        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   977        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   978      case ND6_REACHABLE:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   979        /* Send queued packets, if any are left. Should have been sent already. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   980        if (neighbor_cache[i].q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   981          nd6_send_q(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   982        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   983        if (neighbor_cache[i].counter.reachable_time <= ND6_TMR_INTERVAL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   984          /* Change to stale state. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   985          neighbor_cache[i].state = ND6_STALE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   986          neighbor_cache[i].counter.stale_time = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   987        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   988          neighbor_cache[i].counter.reachable_time -= ND6_TMR_INTERVAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   989        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   990        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   991      case ND6_STALE:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   992        neighbor_cache[i].counter.stale_time++;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   993        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   994      case ND6_DELAY:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   995        if (neighbor_cache[i].counter.delay_time <= 1) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   996          /* Change to PROBE state. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   997          neighbor_cache[i].state = ND6_PROBE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   998          neighbor_cache[i].counter.probes_sent = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	   999        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1000          neighbor_cache[i].counter.delay_time--;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1001        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1002        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1003      case ND6_PROBE:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1004        if ((neighbor_cache[i].counter.probes_sent >= LWIP_ND6_MAX_MULTICAST_SOLICIT) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1005            (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1006          /* Retries exceeded. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1007          nd6_free_neighbor_cache_entry(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1008        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1009          /* Send a NS for this entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1010          neighbor_cache[i].counter.probes_sent++;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1011          nd6_send_neighbor_cache_probe(&neighbor_cache[i], 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1012        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1013        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1014      case ND6_NO_ENTRY:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1015      default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1016        /* Do nothing. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1017        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1018      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1019    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1020  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1021    /* Process destination entries. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1022    for (i = 0; i < LWIP_ND6_NUM_DESTINATIONS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1023      destination_cache[i].age++;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1024    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1025  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1026    /* Process router entries. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1027    for (i = 0; i < LWIP_ND6_NUM_ROUTERS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1028      if (default_router_list[i].neighbor_entry != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1029        /* Active entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1030        if (default_router_list[i].invalidation_timer <= ND6_TMR_INTERVAL / 1000) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1031          /* No more than 1 second remaining. Clear this entry. Also clear any of
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1032           * its destination cache entries, as per RFC 4861 Sec. 5.3 and 6.3.5. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1033          s8_t j;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1034          for (j = 0; j < LWIP_ND6_NUM_DESTINATIONS; j++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1035            if (ip6_addr_cmp(&destination_cache[j].next_hop_addr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1036                 &default_router_list[i].neighbor_entry->next_hop_address)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1037               ip6_addr_set_any(&destination_cache[j].destination_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1038            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1039          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1040          default_router_list[i].neighbor_entry->isrouter = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1041          default_router_list[i].neighbor_entry = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1042          default_router_list[i].invalidation_timer = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1043          default_router_list[i].flags = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1044        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1045          default_router_list[i].invalidation_timer -= ND6_TMR_INTERVAL / 1000;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1046        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1047      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1048    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1049  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1050    /* Process prefix entries. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1051    for (i = 0; i < LWIP_ND6_NUM_PREFIXES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1052      if (prefix_list[i].netif != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1053        if (prefix_list[i].invalidation_timer <= ND6_TMR_INTERVAL / 1000) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1054          /* Entry timed out, remove it */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1055          prefix_list[i].invalidation_timer = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1056          prefix_list[i].netif = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1057        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1058          prefix_list[i].invalidation_timer -= ND6_TMR_INTERVAL / 1000;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1059        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1060      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1061    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1062  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1063    /* Process our own addresses, updating address lifetimes and/or DAD state. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1064    NETIF_FOREACH(netif) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1065      for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; ++i) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1066        u8_t addr_state;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1067  #if LWIP_IPV6_ADDRESS_LIFETIMES
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1068        /* Step 1: update address lifetimes (valid and preferred). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1069        addr_state = netif_ip6_addr_state(netif, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1070        /* RFC 4862 is not entirely clear as to whether address lifetimes affect
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1071         * tentative addresses, and is even less clear as to what should happen
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1072         * with duplicate addresses. We choose to track and update lifetimes for
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1073         * both those types, although for different reasons:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1074         * - for tentative addresses, the line of thought of Sec. 5.7 combined
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1075         *   with the potentially long period that an address may be in tentative
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1076         *   state (due to the interface being down) suggests that lifetimes
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1077         *   should be independent of external factors which would include DAD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1078         * - for duplicate addresses, retiring them early could result in a new
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1079         *   but unwanted attempt at marking them as valid, while retiring them
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1080         *   late/never could clog up address slots on the netif.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1081         * As a result, we may end up expiring addresses of either type here.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1082         */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1083        if (!ip6_addr_isinvalid(addr_state) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1084            !netif_ip6_addr_isstatic(netif, i)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1085          u32_t life = netif_ip6_addr_valid_life(netif, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1086          if (life <= ND6_TMR_INTERVAL / 1000) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1087            /* The address has expired. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1088            netif_ip6_addr_set_valid_life(netif, i, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1089            netif_ip6_addr_set_pref_life(netif, i, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1090            netif_ip6_addr_set_state(netif, i, IP6_ADDR_INVALID);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1091          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1092            if (!ip6_addr_life_isinfinite(life)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1093              life -= ND6_TMR_INTERVAL / 1000;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1094              LWIP_ASSERT("bad valid lifetime", life != IP6_ADDR_LIFE_STATIC);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1095              netif_ip6_addr_set_valid_life(netif, i, life);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1096            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1097            /* The address is still here. Update the preferred lifetime too. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1098            life = netif_ip6_addr_pref_life(netif, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1099            if (life <= ND6_TMR_INTERVAL / 1000) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1100              /* This case must also trigger if 'life' was already zero, so as to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1101               * deal correctly with advertised preferred-lifetime reductions. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1102              netif_ip6_addr_set_pref_life(netif, i, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1103              if (addr_state == IP6_ADDR_PREFERRED)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1104                netif_ip6_addr_set_state(netif, i, IP6_ADDR_DEPRECATED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1105            } else if (!ip6_addr_life_isinfinite(life)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1106              life -= ND6_TMR_INTERVAL / 1000;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1107              netif_ip6_addr_set_pref_life(netif, i, life);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1108            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1109          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1110        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1111        /* The address state may now have changed, so reobtain it next. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1112  #endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1113        /* Step 2: update DAD state. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1114        addr_state = netif_ip6_addr_state(netif, i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1115        if (ip6_addr_istentative(addr_state)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1116          if ((addr_state & IP6_ADDR_TENTATIVE_COUNT_MASK) >= LWIP_IPV6_DUP_DETECT_ATTEMPTS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1117            /* No NA received in response. Mark address as valid. For dynamic
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1118             * addresses with an expired preferred lifetime, the state is set to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1119             * deprecated right away. That should almost never happen, though. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1120            addr_state = IP6_ADDR_PREFERRED;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1121  #if LWIP_IPV6_ADDRESS_LIFETIMES
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1122            if (!netif_ip6_addr_isstatic(netif, i) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1123                netif_ip6_addr_pref_life(netif, i) == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1124              addr_state = IP6_ADDR_DEPRECATED;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1125            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1126  #endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1127            netif_ip6_addr_set_state(netif, i, addr_state);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1128          } else if (netif_is_up(netif) && netif_is_link_up(netif)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1129            /* tentative: set next state by increasing by one */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1130            netif_ip6_addr_set_state(netif, i, addr_state + 1);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1131            /* Send a NS for this address. Use the unspecified address as source
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1132             * address in all cases (RFC 4862 Sec. 5.4.2), not in the least
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1133             * because as it is, we only consider multicast replies for DAD. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1134            nd6_send_ns(netif, netif_ip6_addr(netif, i),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1135              ND6_SEND_FLAG_MULTICAST_DEST | ND6_SEND_FLAG_ANY_SRC);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1136          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1137        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1138      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1139    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1140  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1141  #if LWIP_IPV6_SEND_ROUTER_SOLICIT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1142    /* Send router solicitation messages, if necessary. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1143    if (!nd6_tmr_rs_reduction) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1144      nd6_tmr_rs_reduction = (ND6_RTR_SOLICITATION_INTERVAL / ND6_TMR_INTERVAL) - 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1145      NETIF_FOREACH(netif) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1146        if ((netif->rs_count > 0) && netif_is_up(netif) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1147            netif_is_link_up(netif) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1148            !ip6_addr_isinvalid(netif_ip6_addr_state(netif, 0)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1149            !ip6_addr_isduplicated(netif_ip6_addr_state(netif, 0))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1150          if (nd6_send_rs(netif) == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1151            netif->rs_count--;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1152          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1153        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1154      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1155    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1156      nd6_tmr_rs_reduction--;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1157    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1158  #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1159  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1160  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1161  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1162  /** Send a neighbor solicitation message for a specific neighbor cache entry
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1163   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1164   * @param entry the neightbor cache entry for wich to send the message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1165   * @param flags one of ND6_SEND_FLAG_*
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1166   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1167  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1168  nd6_send_neighbor_cache_probe(struct nd6_neighbor_cache_entry *entry, u8_t flags)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1169  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1170    nd6_send_ns(entry->netif, &entry->next_hop_address, flags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1171  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1172  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1173  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1174   * Send a neighbor solicitation message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1175   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1176   * @param netif the netif on which to send the message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1177   * @param target_addr the IPv6 target address for the ND message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1178   * @param flags one of ND6_SEND_FLAG_*
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1179   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1180  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1181  nd6_send_ns(struct netif *netif, const ip6_addr_t *target_addr, u8_t flags)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1182  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1183    struct ns_header *ns_hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1184    struct pbuf *p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1185    const ip6_addr_t *src_addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1186    u16_t lladdr_opt_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1187  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1188    LWIP_ASSERT("target address is required", target_addr != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1189  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1190    if (!(flags & ND6_SEND_FLAG_ANY_SRC) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1191        ip6_addr_isvalid(netif_ip6_addr_state(netif,0))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1192      /* Use link-local address as source address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1193      src_addr = netif_ip6_addr(netif, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1194      /* calculate option length (in 8-byte-blocks) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1195      lladdr_opt_len = ((netif->hwaddr_len + 2) + 7) >> 3;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1196    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1197      src_addr = IP6_ADDR_ANY6;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1198      /* Option "MUST NOT be included when the source IP address is the unspecified address." */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1199      lladdr_opt_len = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1200    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1201  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1202    /* Allocate a packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1203    p = pbuf_alloc(PBUF_IP, sizeof(struct ns_header) + (lladdr_opt_len << 3), PBUF_RAM);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1204    if (p == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1205      ND6_STATS_INC(nd6.memerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1206      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1207    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1208  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1209    /* Set fields. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1210    ns_hdr = (struct ns_header *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1211  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1212    ns_hdr->type = ICMP6_TYPE_NS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1213    ns_hdr->code = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1214    ns_hdr->chksum = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1215    ns_hdr->reserved = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1216    ip6_addr_copy_to_packed(ns_hdr->target_address, *target_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1217  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1218    if (lladdr_opt_len != 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1219      struct lladdr_option *lladdr_opt = (struct lladdr_option *)((u8_t*)p->payload + sizeof(struct ns_header));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1220      lladdr_opt->type = ND6_OPTION_TYPE_SOURCE_LLADDR;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1221      lladdr_opt->length = (u8_t)lladdr_opt_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1222      SMEMCPY(lladdr_opt->addr, netif->hwaddr, netif->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1223    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1224  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1225    /* Generate the solicited node address for the target address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1226    if (flags & ND6_SEND_FLAG_MULTICAST_DEST) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1227      ip6_addr_set_solicitednode(&multicast_address, target_addr->addr[3]);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1228      ip6_addr_assign_zone(&multicast_address, IP6_MULTICAST, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1229      target_addr = &multicast_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1230    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1231  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1232  #if CHECKSUM_GEN_ICMP6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1233    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP6) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1234      ns_hdr->chksum = ip6_chksum_pseudo(p, IP6_NEXTH_ICMP6, p->len, src_addr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1235        target_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1236    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1237  #endif /* CHECKSUM_GEN_ICMP6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1238  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1239    /* Send the packet out. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1240    ND6_STATS_INC(nd6.xmit);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1241    ip6_output_if(p, (src_addr == IP6_ADDR_ANY6) ? NULL : src_addr, target_addr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1242        ND6_HOPLIM, 0, IP6_NEXTH_ICMP6, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1243    pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1244  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1245  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1246  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1247   * Send a neighbor advertisement message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1248   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1249   * @param netif the netif on which to send the message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1250   * @param target_addr the IPv6 target address for the ND message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1251   * @param flags one of ND6_SEND_FLAG_*
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1252   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1253  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1254  nd6_send_na(struct netif *netif, const ip6_addr_t *target_addr, u8_t flags)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1255  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1256    struct na_header *na_hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1257    struct lladdr_option *lladdr_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1258    struct pbuf *p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1259    const ip6_addr_t *src_addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1260    const ip6_addr_t *dest_addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1261    u16_t lladdr_opt_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1262  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1263    LWIP_ASSERT("target address is required", target_addr != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1264  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1265    /* Use link-local address as source address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1266    /* src_addr = netif_ip6_addr(netif, 0); */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1267    /* Use target address as source address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1268    src_addr = target_addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1269  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1270    /* Allocate a packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1271    lladdr_opt_len = ((netif->hwaddr_len + 2) >> 3) + (((netif->hwaddr_len + 2) & 0x07) ? 1 : 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1272    p = pbuf_alloc(PBUF_IP, sizeof(struct na_header) + (lladdr_opt_len << 3), PBUF_RAM);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1273    if (p == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1274      ND6_STATS_INC(nd6.memerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1275      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1276    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1277  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1278    /* Set fields. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1279    na_hdr = (struct na_header *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1280    lladdr_opt = (struct lladdr_option *)((u8_t*)p->payload + sizeof(struct na_header));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1281  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1282    na_hdr->type = ICMP6_TYPE_NA;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1283    na_hdr->code = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1284    na_hdr->chksum = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1285    na_hdr->flags = flags & 0xf0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1286    na_hdr->reserved[0] = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1287    na_hdr->reserved[1] = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1288    na_hdr->reserved[2] = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1289    ip6_addr_copy_to_packed(na_hdr->target_address, *target_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1290  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1291    lladdr_opt->type = ND6_OPTION_TYPE_TARGET_LLADDR;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1292    lladdr_opt->length = (u8_t)lladdr_opt_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1293    SMEMCPY(lladdr_opt->addr, netif->hwaddr, netif->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1294  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1295    /* Generate the solicited node address for the target address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1296    if (flags & ND6_SEND_FLAG_MULTICAST_DEST) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1297      ip6_addr_set_solicitednode(&multicast_address, target_addr->addr[3]);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1298      ip6_addr_assign_zone(&multicast_address, IP6_MULTICAST, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1299      dest_addr = &multicast_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1300    } else if (flags & ND6_SEND_FLAG_ALLNODES_DEST) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1301      ip6_addr_set_allnodes_linklocal(&multicast_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1302      ip6_addr_assign_zone(&multicast_address, IP6_MULTICAST, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1303      dest_addr = &multicast_address;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1304    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1305      dest_addr = ip6_current_src_addr();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1306    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1307  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1308  #if CHECKSUM_GEN_ICMP6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1309    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP6) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1310      na_hdr->chksum = ip6_chksum_pseudo(p, IP6_NEXTH_ICMP6, p->len, src_addr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1311        dest_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1312    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1313  #endif /* CHECKSUM_GEN_ICMP6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1314  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1315    /* Send the packet out. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1316    ND6_STATS_INC(nd6.xmit);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1317    ip6_output_if(p, src_addr, dest_addr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1318        ND6_HOPLIM, 0, IP6_NEXTH_ICMP6, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1319    pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1320  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1321  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1322  #if LWIP_IPV6_SEND_ROUTER_SOLICIT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1323  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1324   * Send a router solicitation message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1325   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1326   * @param netif the netif on which to send the message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1327   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1328  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1329  nd6_send_rs(struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1330  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1331    struct rs_header *rs_hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1332    struct lladdr_option *lladdr_opt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1333    struct pbuf *p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1334    const ip6_addr_t *src_addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1335    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1336    u16_t lladdr_opt_len = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1337  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1338    /* Link-local source address, or unspecified address? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1339    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, 0))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1340      src_addr = netif_ip6_addr(netif, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1341    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1342      src_addr = IP6_ADDR_ANY6;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1343    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1344  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1345    /* Generate the all routers target address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1346    ip6_addr_set_allrouters_linklocal(&multicast_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1347    ip6_addr_assign_zone(&multicast_address, IP6_MULTICAST, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1348  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1349    /* Allocate a packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1350    if (src_addr != IP6_ADDR_ANY6) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1351      lladdr_opt_len = ((netif->hwaddr_len + 2) >> 3) + (((netif->hwaddr_len + 2) & 0x07) ? 1 : 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1352    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1353    p = pbuf_alloc(PBUF_IP, sizeof(struct rs_header) + (lladdr_opt_len << 3), PBUF_RAM);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1354    if (p == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1355      ND6_STATS_INC(nd6.memerr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1356      return ERR_BUF;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1357    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1358  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1359    /* Set fields. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1360    rs_hdr = (struct rs_header *)p->payload;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1361  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1362    rs_hdr->type = ICMP6_TYPE_RS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1363    rs_hdr->code = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1364    rs_hdr->chksum = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1365    rs_hdr->reserved = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1366  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1367    if (src_addr != IP6_ADDR_ANY6) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1368      /* Include our hw address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1369      lladdr_opt = (struct lladdr_option *)((u8_t*)p->payload + sizeof(struct rs_header));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1370      lladdr_opt->type = ND6_OPTION_TYPE_SOURCE_LLADDR;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1371      lladdr_opt->length = (u8_t)lladdr_opt_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1372      SMEMCPY(lladdr_opt->addr, netif->hwaddr, netif->hwaddr_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1373    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1374  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1375  #if CHECKSUM_GEN_ICMP6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1376    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP6) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1377      rs_hdr->chksum = ip6_chksum_pseudo(p, IP6_NEXTH_ICMP6, p->len, src_addr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1378        &multicast_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1379    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1380  #endif /* CHECKSUM_GEN_ICMP6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1381  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1382    /* Send the packet out. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1383    ND6_STATS_INC(nd6.xmit);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1384  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1385    err = ip6_output_if(p, (src_addr == IP6_ADDR_ANY6) ? NULL : src_addr, &multicast_address,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1386        ND6_HOPLIM, 0, IP6_NEXTH_ICMP6, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1387    pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1388  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1389    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1390  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1391  #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1392  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1393  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1394   * Search for a neighbor cache entry
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1395   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1396   * @param ip6addr the IPv6 address of the neighbor
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1397   * @return The neighbor cache entry index that matched, -1 if no
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1398   * entry is found
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1399   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1400  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1401  nd6_find_neighbor_cache_entry(const ip6_addr_t *ip6addr)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1402  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1403    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1404    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1405      if (ip6_addr_cmp(ip6addr, &(neighbor_cache[i].next_hop_address))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1406        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1407      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1408    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1409    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1410  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1411  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1412  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1413   * Create a new neighbor cache entry.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1414   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1415   * If no unused entry is found, will try to recycle an old entry
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1416   * according to ad-hoc "age" heuristic.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1417   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1418   * @return The neighbor cache entry index that was created, -1 if no
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1419   * entry could be created
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1420   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1421  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1422  nd6_new_neighbor_cache_entry(void)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1423  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1424    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1425    s8_t j;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1426    u32_t time;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1427  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1428  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1429    /* First, try to find an empty entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1430    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1431      if (neighbor_cache[i].state == ND6_NO_ENTRY) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1432        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1433      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1434    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1435  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1436    /* We need to recycle an entry. in general, do not recycle if it is a router. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1437  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1438    /* Next, try to find a Stale entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1439    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1440      if ((neighbor_cache[i].state == ND6_STALE) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1441          (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1442        nd6_free_neighbor_cache_entry(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1443        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1444      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1445    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1446  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1447    /* Next, try to find a Probe entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1448    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1449      if ((neighbor_cache[i].state == ND6_PROBE) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1450          (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1451        nd6_free_neighbor_cache_entry(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1452        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1453      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1454    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1455  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1456    /* Next, try to find a Delayed entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1457    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1458      if ((neighbor_cache[i].state == ND6_DELAY) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1459          (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1460        nd6_free_neighbor_cache_entry(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1461        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1462      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1463    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1464  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1465    /* Next, try to find the oldest reachable entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1466    time = 0xfffffffful;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1467    j = -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1468    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1469      if ((neighbor_cache[i].state == ND6_REACHABLE) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1470          (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1471        if (neighbor_cache[i].counter.reachable_time < time) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1472          j = i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1473          time = neighbor_cache[i].counter.reachable_time;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1474        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1475      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1476    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1477    if (j >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1478      nd6_free_neighbor_cache_entry(j);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1479      return j;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1480    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1481  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1482    /* Next, find oldest incomplete entry without queued packets. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1483    time = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1484    j = -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1485    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1486      if (
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1487          (neighbor_cache[i].q == NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1488          (neighbor_cache[i].state == ND6_INCOMPLETE) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1489          (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1490        if (neighbor_cache[i].counter.probes_sent >= time) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1491          j = i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1492          time = neighbor_cache[i].counter.probes_sent;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1493        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1494      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1495    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1496    if (j >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1497      nd6_free_neighbor_cache_entry(j);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1498      return j;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1499    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1500  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1501    /* Next, find oldest incomplete entry with queued packets. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1502    time = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1503    j = -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1504    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1505      if ((neighbor_cache[i].state == ND6_INCOMPLETE) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1506          (!neighbor_cache[i].isrouter)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1507        if (neighbor_cache[i].counter.probes_sent >= time) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1508          j = i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1509          time = neighbor_cache[i].counter.probes_sent;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1510        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1511      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1512    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1513    if (j >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1514      nd6_free_neighbor_cache_entry(j);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1515      return j;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1516    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1517  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1518    /* No more entries to try. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1519    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1520  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1521  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1522  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1523   * Will free any resources associated with a neighbor cache
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1524   * entry, and will mark it as unused.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1525   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1526   * @param i the neighbor cache entry index to free
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1527   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1528  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1529  nd6_free_neighbor_cache_entry(s8_t i)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1530  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1531    if ((i < 0) || (i >= LWIP_ND6_NUM_NEIGHBORS)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1532      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1533    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1534    if (neighbor_cache[i].isrouter) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1535      /* isrouter needs to be cleared before deleting a neighbor cache entry */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1536      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1537    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1538  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1539    /* Free any queued packets. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1540    if (neighbor_cache[i].q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1541      nd6_free_q(neighbor_cache[i].q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1542      neighbor_cache[i].q = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1543    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1544  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1545    neighbor_cache[i].state = ND6_NO_ENTRY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1546    neighbor_cache[i].isrouter = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1547    neighbor_cache[i].netif = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1548    neighbor_cache[i].counter.reachable_time = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1549    ip6_addr_set_zero(&(neighbor_cache[i].next_hop_address));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1550  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1551  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1552  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1553   * Search for a destination cache entry
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1554   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1555   * @param ip6addr the IPv6 address of the destination
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1556   * @return The destination cache entry index that matched, -1 if no
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1557   * entry is found
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1558   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1559  static s16_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1560  nd6_find_destination_cache_entry(const ip6_addr_t *ip6addr)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1561  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1562    s16_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1563  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1564    IP6_ADDR_ZONECHECK(ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1565  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1566    for (i = 0; i < LWIP_ND6_NUM_DESTINATIONS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1567      if (ip6_addr_cmp(ip6addr, &(destination_cache[i].destination_addr))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1568        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1569      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1570    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1571    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1572  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1573  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1574  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1575   * Create a new destination cache entry. If no unused entry is found,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1576   * will recycle oldest entry.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1577   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1578   * @return The destination cache entry index that was created, -1 if no
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1579   * entry was created
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1580   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1581  static s16_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1582  nd6_new_destination_cache_entry(void)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1583  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1584    s16_t i, j;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1585    u32_t age;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1586  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1587    /* Find an empty entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1588    for (i = 0; i < LWIP_ND6_NUM_DESTINATIONS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1589      if (ip6_addr_isany(&(destination_cache[i].destination_addr))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1590        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1591      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1592    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1593  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1594    /* Find oldest entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1595    age = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1596    j = LWIP_ND6_NUM_DESTINATIONS - 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1597    for (i = 0; i < LWIP_ND6_NUM_DESTINATIONS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1598      if (destination_cache[i].age > age) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1599        j = i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1600      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1601    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1602  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1603    return j;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1604  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1605  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1606  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1607   * Clear the destination cache.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1608   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1609   * This operation may be necessary for consistency in the light of changing
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1610   * local addresses and/or use of the gateway hook.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1611   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1612  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1613  nd6_clear_destination_cache(void)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1614  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1615    int i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1616  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1617    for (i = 0; i < LWIP_ND6_NUM_DESTINATIONS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1618      ip6_addr_set_any(&destination_cache[i].destination_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1619    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1620  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1621  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1622  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1623   * Determine whether an address matches an on-link prefix or the subnet of a
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1624   * statically assigned address.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1625   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1626   * @param ip6addr the IPv6 address to match
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1627   * @return 1 if the address is on-link, 0 otherwise
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1628   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1629  static int
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1630  nd6_is_prefix_in_netif(const ip6_addr_t *ip6addr, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1631  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1632    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1633  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1634    /* Check to see if the address matches an on-link prefix. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1635    for (i = 0; i < LWIP_ND6_NUM_PREFIXES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1636      if ((prefix_list[i].netif == netif) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1637          (prefix_list[i].invalidation_timer > 0) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1638          ip6_addr_netcmp(ip6addr, &(prefix_list[i].prefix))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1639        return 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1640      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1641    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1642    /* Check to see if address prefix matches a manually configured (= static)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1643     * address. Static addresses have an implied /64 subnet assignment. Dynamic
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1644     * addresses (from autoconfiguration) have no implied subnet assignment, and
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1645     * are thus effectively /128 assignments. See RFC 5942 for more on this. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1646    for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1647      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1648          netif_ip6_addr_isstatic(netif, i) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1649          ip6_addr_netcmp(ip6addr, netif_ip6_addr(netif, i))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1650        return 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1651      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1652    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1653    return 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1654  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1655  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1656  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1657   * Select a default router for a destination.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1658   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1659   * This function is used both for routing and for finding a next-hop target for
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1660   * a packet. In the former case, the given netif is NULL, and the returned
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1661   * router entry must be for a netif suitable for sending packets (up, link up).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1662   * In the latter case, the given netif is not NULL and restricts router choice.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1663   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1664   * @param ip6addr the destination address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1665   * @param netif the netif for the outgoing packet, if known
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1666   * @return the default router entry index, or -1 if no suitable
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1667   *         router is found
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1668   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1669  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1670  nd6_select_router(const ip6_addr_t *ip6addr, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1671  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1672    struct netif *router_netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1673    s8_t i, j, valid_router;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1674    static s8_t last_router;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1675  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1676    LWIP_UNUSED_ARG(ip6addr); /* @todo match preferred routes!! (must implement ND6_OPTION_TYPE_ROUTE_INFO) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1677  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1678    /* @todo: implement default router preference */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1679  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1680    /* Look for valid routers. A reachable router is preferred. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1681    valid_router = -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1682    for (i = 0; i < LWIP_ND6_NUM_ROUTERS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1683      /* Is the router netif both set and apppropriate? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1684      if (default_router_list[i].neighbor_entry != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1685        router_netif = default_router_list[i].neighbor_entry->netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1686        if ((router_netif != NULL) && (netif != NULL ? netif == router_netif :
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1687            (netif_is_up(router_netif) && netif_is_link_up(router_netif)))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1688          /* Is the router valid, i.e., reachable or probably reachable as per
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1689           * RFC 4861 Sec. 6.3.6? Note that we will never return a router that
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1690           * has no neighbor cache entry, due to the netif association tests. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1691          if (default_router_list[i].neighbor_entry->state != ND6_INCOMPLETE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1692            /* Is the router known to be reachable? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1693            if (default_router_list[i].neighbor_entry->state == ND6_REACHABLE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1694              return i; /* valid and reachable - done! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1695            } else if (valid_router < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1696              valid_router = i; /* valid but not known to be reachable */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1697            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1698          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1699        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1700      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1701    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1702    if (valid_router >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1703      return valid_router;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1704    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1705  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1706    /* Look for any router for which we have any information at all. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1707    /* last_router is used for round-robin selection of incomplete routers, as
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1708     * recommended in RFC 4861 Sec. 6.3.6 point (2). Advance only when picking a
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1709     * route, to select the same router as next-hop target in the common case. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1710    if ((netif == NULL) && (++last_router >= LWIP_ND6_NUM_ROUTERS)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1711      last_router = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1712    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1713    i = last_router;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1714    for (j = 0; j < LWIP_ND6_NUM_ROUTERS; j++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1715      if (default_router_list[i].neighbor_entry != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1716        router_netif = default_router_list[i].neighbor_entry->netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1717        if ((router_netif != NULL) && (netif != NULL ? netif == router_netif :
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1718            (netif_is_up(router_netif) && netif_is_link_up(router_netif)))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1719          return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1720        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1721      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1722      if (++i >= LWIP_ND6_NUM_ROUTERS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1723        i = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1724      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1725    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1726  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1727    /* no suitable router found. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1728    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1729  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1730  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1731  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1732   * Find a router-announced route to the given destination. This route may be
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1733   * based on an on-link prefix or a default router.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1734   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1735   * If a suitable route is found, the returned netif is guaranteed to be in a
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1736   * suitable state (up, link up) to be used for packet transmission.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1737   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1738   * @param ip6addr the destination IPv6 address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1739   * @return the netif to use for the destination, or NULL if none found
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1740   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1741  struct netif *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1742  nd6_find_route(const ip6_addr_t *ip6addr)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1743  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1744    struct netif *netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1745    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1746  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1747    /* @todo decide if it makes sense to check the destination cache first */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1748  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1749    /* Check if there is a matching on-link prefix. There may be multiple
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1750     * matches. Pick the first one that is associated with a suitable netif. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1751    for (i = 0; i < LWIP_ND6_NUM_PREFIXES; ++i) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1752      netif = prefix_list[i].netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1753      if ((netif != NULL) && ip6_addr_netcmp(&prefix_list[i].prefix, ip6addr) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1754          netif_is_up(netif) && netif_is_link_up(netif)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1755        return netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1756      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1757    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1758  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1759    /* No on-link prefix match. Find a router that can forward the packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1760    i = nd6_select_router(ip6addr, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1761    if (i >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1762      LWIP_ASSERT("selected router must have a neighbor entry",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1763        default_router_list[i].neighbor_entry != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1764      return default_router_list[i].neighbor_entry->netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1765    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1766  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1767    return NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1768  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1769  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1770  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1771   * Find an entry for a default router.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1772   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1773   * @param router_addr the IPv6 address of the router
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1774   * @param netif the netif on which the router is found, if known
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1775   * @return the index of the router entry, or -1 if not found
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1776   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1777  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1778  nd6_get_router(const ip6_addr_t *router_addr, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1779  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1780    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1781  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1782    IP6_ADDR_ZONECHECK_NETIF(router_addr, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1783  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1784    /* Look for router. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1785    for (i = 0; i < LWIP_ND6_NUM_ROUTERS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1786      if ((default_router_list[i].neighbor_entry != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1787          ((netif != NULL) ? netif == default_router_list[i].neighbor_entry->netif : 1) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1788          ip6_addr_cmp(router_addr, &(default_router_list[i].neighbor_entry->next_hop_address))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1789        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1790      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1791    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1792  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1793    /* router not found. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1794    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1795  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1796  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1797  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1798   * Create a new entry for a default router.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1799   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1800   * @param router_addr the IPv6 address of the router
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1801   * @param netif the netif on which the router is connected, if known
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1802   * @return the index on the router table, or -1 if could not be created
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1803   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1804  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1805  nd6_new_router(const ip6_addr_t *router_addr, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1806  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1807    s8_t router_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1808    s8_t free_router_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1809    s8_t neighbor_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1810  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1811    IP6_ADDR_ZONECHECK_NETIF(router_addr, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1812  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1813    /* Do we have a neighbor entry for this router? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1814    neighbor_index = nd6_find_neighbor_cache_entry(router_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1815    if (neighbor_index < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1816      /* Create a neighbor entry for this router. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1817      neighbor_index = nd6_new_neighbor_cache_entry();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1818      if (neighbor_index < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1819        /* Could not create neighbor entry for this router. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1820        return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1821      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1822      ip6_addr_set(&(neighbor_cache[neighbor_index].next_hop_address), router_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1823      neighbor_cache[neighbor_index].netif = netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1824      neighbor_cache[neighbor_index].q = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1825      neighbor_cache[neighbor_index].state = ND6_INCOMPLETE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1826      neighbor_cache[neighbor_index].counter.probes_sent = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1827      nd6_send_neighbor_cache_probe(&neighbor_cache[neighbor_index], ND6_SEND_FLAG_MULTICAST_DEST);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1828    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1829  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1830    /* Mark neighbor as router. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1831    neighbor_cache[neighbor_index].isrouter = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1832  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1833    /* Look for empty entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1834    free_router_index = LWIP_ND6_NUM_ROUTERS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1835    for (router_index = LWIP_ND6_NUM_ROUTERS - 1; router_index >= 0; router_index--) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1836      /* check if router already exists (this is a special case for 2 netifs on the same subnet
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1837         - e.g. wifi and cable) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1838      if(default_router_list[router_index].neighbor_entry == &(neighbor_cache[neighbor_index])){ 
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1839        return router_index; 
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1840      } 
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1841      if (default_router_list[router_index].neighbor_entry == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1842        /* remember lowest free index to create a new entry */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1843        free_router_index = router_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1844      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1845    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1846    if (free_router_index < LWIP_ND6_NUM_ROUTERS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1847      default_router_list[free_router_index].neighbor_entry = &(neighbor_cache[neighbor_index]);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1848      return free_router_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1849    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1850  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1851    /* Could not create a router entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1852  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1853    /* Mark neighbor entry as not-router. Entry might be useful as neighbor still. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1854    neighbor_cache[neighbor_index].isrouter = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1855  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1856    /* router not found. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1857    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1858  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1859  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1860  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1861   * Find the cached entry for an on-link prefix.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1862   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1863   * @param prefix the IPv6 prefix that is on-link
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1864   * @param netif the netif on which the prefix is on-link
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1865   * @return the index on the prefix table, or -1 if not found
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1866   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1867  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1868  nd6_get_onlink_prefix(const ip6_addr_t *prefix, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1869  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1870    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1871  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1872    /* Look for prefix in list. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1873    for (i = 0; i < LWIP_ND6_NUM_PREFIXES; ++i) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1874      if ((ip6_addr_netcmp(&(prefix_list[i].prefix), prefix)) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1875          (prefix_list[i].netif == netif)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1876        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1877      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1878    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1879  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1880    /* Entry not available. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1881    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1882  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1883  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1884  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1885   * Creates a new entry for an on-link prefix.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1886   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1887   * @param prefix the IPv6 prefix that is on-link
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1888   * @param netif the netif on which the prefix is on-link
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1889   * @return the index on the prefix table, or -1 if not created
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1890   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1891  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1892  nd6_new_onlink_prefix(const ip6_addr_t *prefix, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1893  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1894    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1895  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1896    /* Create new entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1897    for (i = 0; i < LWIP_ND6_NUM_PREFIXES; ++i) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1898      if ((prefix_list[i].netif == NULL) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1899          (prefix_list[i].invalidation_timer == 0)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1900        /* Found empty prefix entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1901        prefix_list[i].netif = netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1902        ip6_addr_set(&(prefix_list[i].prefix), prefix);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1903        return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1904      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1905    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1906  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1907    /* Entry not available. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1908    return -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1909  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1910  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1911  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1912   * Determine the next hop for a destination. Will determine if the
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1913   * destination is on-link, else a suitable on-link router is selected.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1914   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1915   * The last entry index is cached for fast entry search.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1916   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1917   * @param ip6addr the destination address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1918   * @param netif the netif on which the packet will be sent
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1919   * @return the neighbor cache entry for the next hop, ERR_RTE if no
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1920   *         suitable next hop was found, ERR_MEM if no cache entry
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1921   *         could be created
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1922   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1923  static s8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1924  nd6_get_next_hop_entry(const ip6_addr_t *ip6addr, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1925  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1926  #ifdef LWIP_HOOK_ND6_GET_GW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1927    const ip6_addr_t *next_hop_addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1928  #endif /* LWIP_HOOK_ND6_GET_GW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1929    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1930    s16_t dst_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1931  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1932    IP6_ADDR_ZONECHECK_NETIF(ip6addr, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1933  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1934  #if LWIP_NETIF_HWADDRHINT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1935    if (netif->hints != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1936      /* per-pcb cached entry was given */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1937      netif_addr_idx_t addr_hint = netif->hints->addr_hint;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1938      if (addr_hint < LWIP_ND6_NUM_DESTINATIONS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1939        nd6_cached_destination_index = addr_hint;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1940      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1941    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1942  #endif /* LWIP_NETIF_HWADDRHINT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1943  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1944    /* Look for ip6addr in destination cache. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1945    if (ip6_addr_cmp(ip6addr, &(destination_cache[nd6_cached_destination_index].destination_addr))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1946      /* the cached entry index is the right one! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1947      /* do nothing. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1948      ND6_STATS_INC(nd6.cachehit);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1949    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1950      /* Search destination cache. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1951      dst_idx = nd6_find_destination_cache_entry(ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1952      if (dst_idx >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1953        /* found destination entry. make it our new cached index. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1954        LWIP_ASSERT("type overflow", (size_t)dst_idx < NETIF_ADDR_IDX_MAX);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1955        nd6_cached_destination_index = (netif_addr_idx_t)dst_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1956      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1957        /* Not found. Create a new destination entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1958        dst_idx = nd6_new_destination_cache_entry();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1959        if (dst_idx >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1960          /* got new destination entry. make it our new cached index. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1961          LWIP_ASSERT("type overflow", (size_t)dst_idx < NETIF_ADDR_IDX_MAX);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1962          nd6_cached_destination_index = (netif_addr_idx_t)dst_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1963        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1964          /* Could not create a destination cache entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1965          return ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1966        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1967  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1968        /* Copy dest address to destination cache. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1969        ip6_addr_set(&(destination_cache[nd6_cached_destination_index].destination_addr), ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1970  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1971        /* Now find the next hop. is it a neighbor? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1972        if (ip6_addr_islinklocal(ip6addr) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1973            nd6_is_prefix_in_netif(ip6addr, netif)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1974          /* Destination in local link. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1975          destination_cache[nd6_cached_destination_index].pmtu = netif_mtu6(netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1976          ip6_addr_copy(destination_cache[nd6_cached_destination_index].next_hop_addr, destination_cache[nd6_cached_destination_index].destination_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1977  #ifdef LWIP_HOOK_ND6_GET_GW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1978        } else if ((next_hop_addr = LWIP_HOOK_ND6_GET_GW(netif, ip6addr)) != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1979          /* Next hop for destination provided by hook function. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1980          destination_cache[nd6_cached_destination_index].pmtu = netif->mtu;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1981          ip6_addr_set(&destination_cache[nd6_cached_destination_index].next_hop_addr, next_hop_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1982  #endif /* LWIP_HOOK_ND6_GET_GW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1983        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1984          /* We need to select a router. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1985          i = nd6_select_router(ip6addr, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1986          if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1987            /* No router found. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1988            ip6_addr_set_any(&(destination_cache[nd6_cached_destination_index].destination_addr));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1989            return ERR_RTE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1990          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1991          destination_cache[nd6_cached_destination_index].pmtu = netif_mtu6(netif); /* Start with netif mtu, correct through ICMPv6 if necessary */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1992          ip6_addr_copy(destination_cache[nd6_cached_destination_index].next_hop_addr, default_router_list[i].neighbor_entry->next_hop_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1993        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1994      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1995    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1996  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1997  #if LWIP_NETIF_HWADDRHINT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1998    if (netif->hints != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  1999      /* per-pcb cached entry was given */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2000      netif->hints->addr_hint = nd6_cached_destination_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2001    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2002  #endif /* LWIP_NETIF_HWADDRHINT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2003  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2004    /* Look in neighbor cache for the next-hop address. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2005    if (ip6_addr_cmp(&(destination_cache[nd6_cached_destination_index].next_hop_addr),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2006                     &(neighbor_cache[nd6_cached_neighbor_index].next_hop_address))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2007      /* Cache hit. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2008      /* Do nothing. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2009      ND6_STATS_INC(nd6.cachehit);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2010    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2011      i = nd6_find_neighbor_cache_entry(&(destination_cache[nd6_cached_destination_index].next_hop_addr));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2012      if (i >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2013        /* Found a matching record, make it new cached entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2014        nd6_cached_neighbor_index = i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2015      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2016        /* Neighbor not in cache. Make a new entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2017        i = nd6_new_neighbor_cache_entry();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2018        if (i >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2019          /* got new neighbor entry. make it our new cached index. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2020          nd6_cached_neighbor_index = i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2021        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2022          /* Could not create a neighbor cache entry. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2023          return ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2024        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2025  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2026        /* Initialize fields. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2027        ip6_addr_copy(neighbor_cache[i].next_hop_address,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2028                     destination_cache[nd6_cached_destination_index].next_hop_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2029        neighbor_cache[i].isrouter = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2030        neighbor_cache[i].netif = netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2031        neighbor_cache[i].state = ND6_INCOMPLETE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2032        neighbor_cache[i].counter.probes_sent = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2033        nd6_send_neighbor_cache_probe(&neighbor_cache[i], ND6_SEND_FLAG_MULTICAST_DEST);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2034      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2035    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2036  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2037    /* Reset this destination's age. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2038    destination_cache[nd6_cached_destination_index].age = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2039  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2040    return nd6_cached_neighbor_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2041  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2042  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2043  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2044   * Queue a packet for a neighbor.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2045   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2046   * @param neighbor_index the index in the neighbor cache table
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2047   * @param q packet to be queued
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2048   * @return ERR_OK if succeeded, ERR_MEM if out of memory
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2049   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2050  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2051  nd6_queue_packet(s8_t neighbor_index, struct pbuf *q)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2052  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2053    err_t result = ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2054    struct pbuf *p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2055    int copy_needed = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2056  #if LWIP_ND6_QUEUEING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2057    struct nd6_q_entry *new_entry, *r;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2058  #endif /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2059  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2060    if ((neighbor_index < 0) || (neighbor_index >= LWIP_ND6_NUM_NEIGHBORS)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2061      return ERR_ARG;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2062    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2063  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2064    /* IF q includes a pbuf that must be copied, we have to copy the whole chain
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2065     * into a new PBUF_RAM. See the definition of PBUF_NEEDS_COPY for details. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2066    p = q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2067    while (p) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2068      if (PBUF_NEEDS_COPY(p)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2069        copy_needed = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2070        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2071      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2072      p = p->next;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2073    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2074    if (copy_needed) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2075      /* copy the whole packet into new pbufs */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2076      p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2077      while ((p == NULL) && (neighbor_cache[neighbor_index].q != NULL)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2078        /* Free oldest packet (as per RFC recommendation) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2079  #if LWIP_ND6_QUEUEING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2080        r = neighbor_cache[neighbor_index].q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2081        neighbor_cache[neighbor_index].q = r->next;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2082        r->next = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2083        nd6_free_q(r);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2084  #else /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2085        pbuf_free(neighbor_cache[neighbor_index].q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2086        neighbor_cache[neighbor_index].q = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2087  #endif /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2088        p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2089      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2090    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2091      /* referencing the old pbuf is enough */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2092      p = q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2093      pbuf_ref(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2094    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2095    /* packet was copied/ref'd? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2096    if (p != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2097      /* queue packet ... */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2098  #if LWIP_ND6_QUEUEING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2099      /* allocate a new nd6 queue entry */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2100      new_entry = (struct nd6_q_entry *)memp_malloc(MEMP_ND6_QUEUE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2101      if ((new_entry == NULL) && (neighbor_cache[neighbor_index].q != NULL)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2102        /* Free oldest packet (as per RFC recommendation) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2103        r = neighbor_cache[neighbor_index].q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2104        neighbor_cache[neighbor_index].q = r->next;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2105        r->next = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2106        nd6_free_q(r);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2107        new_entry = (struct nd6_q_entry *)memp_malloc(MEMP_ND6_QUEUE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2108      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2109      if (new_entry != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2110        new_entry->next = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2111        new_entry->p = p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2112        if (neighbor_cache[neighbor_index].q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2113          /* queue was already existent, append the new entry to the end */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2114          r = neighbor_cache[neighbor_index].q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2115          while (r->next != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2116            r = r->next;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2117          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2118          r->next = new_entry;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2119        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2120          /* queue did not exist, first item in queue */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2121          neighbor_cache[neighbor_index].q = new_entry;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2122        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2123        LWIP_DEBUGF(LWIP_DBG_TRACE, ("ipv6: queued packet %p on neighbor entry %"S16_F"\n", (void *)p, (s16_t)neighbor_index));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2124        result = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2125      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2126        /* the pool MEMP_ND6_QUEUE is empty */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2127        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2128        LWIP_DEBUGF(LWIP_DBG_TRACE, ("ipv6: could not queue a copy of packet %p (out of memory)\n", (void *)p));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2129        /* { result == ERR_MEM } through initialization */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2130      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2131  #else /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2132      /* Queue a single packet. If an older packet is already queued, free it as per RFC. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2133      if (neighbor_cache[neighbor_index].q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2134        pbuf_free(neighbor_cache[neighbor_index].q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2135      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2136      neighbor_cache[neighbor_index].q = p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2137      LWIP_DEBUGF(LWIP_DBG_TRACE, ("ipv6: queued packet %p on neighbor entry %"S16_F"\n", (void *)p, (s16_t)neighbor_index));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2138      result = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2139  #endif /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2140    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2141      LWIP_DEBUGF(LWIP_DBG_TRACE, ("ipv6: could not queue a copy of packet %p (out of memory)\n", (void *)q));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2142      /* { result == ERR_MEM } through initialization */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2143    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2144  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2145    return result;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2146  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2147  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2148  #if LWIP_ND6_QUEUEING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2149  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2150   * Free a complete queue of nd6 q entries
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2151   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2152   * @param q a queue of nd6_q_entry to free
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2153   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2154  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2155  nd6_free_q(struct nd6_q_entry *q)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2156  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2157    struct nd6_q_entry *r;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2158    LWIP_ASSERT("q != NULL", q != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2159    LWIP_ASSERT("q->p != NULL", q->p != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2160    while (q) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2161      r = q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2162      q = q->next;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2163      LWIP_ASSERT("r->p != NULL", (r->p != NULL));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2164      pbuf_free(r->p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2165      memp_free(MEMP_ND6_QUEUE, r);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2166    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2167  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2168  #endif /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2169  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2170  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2171   * Send queued packets for a neighbor
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2172   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2173   * @param i the neighbor to send packets to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2174   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2175  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2176  nd6_send_q(s8_t i)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2177  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2178    struct ip6_hdr *ip6hdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2179    ip6_addr_t dest;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2180  #if LWIP_ND6_QUEUEING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2181    struct nd6_q_entry *q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2182  #endif /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2183  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2184    if ((i < 0) || (i >= LWIP_ND6_NUM_NEIGHBORS)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2185      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2186    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2187  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2188  #if LWIP_ND6_QUEUEING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2189    while (neighbor_cache[i].q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2190      /* remember first in queue */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2191      q = neighbor_cache[i].q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2192      /* pop first item off the queue */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2193      neighbor_cache[i].q = q->next;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2194      /* Get ipv6 header. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2195      ip6hdr = (struct ip6_hdr *)(q->p->payload);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2196      /* Create an aligned copy. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2197      ip6_addr_copy_from_packed(dest, ip6hdr->dest);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2198      /* Restore the zone, if applicable. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2199      ip6_addr_assign_zone(&dest, IP6_UNKNOWN, neighbor_cache[i].netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2200      /* send the queued IPv6 packet */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2201      (neighbor_cache[i].netif)->output_ip6(neighbor_cache[i].netif, q->p, &dest);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2202      /* free the queued IP packet */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2203      pbuf_free(q->p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2204      /* now queue entry can be freed */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2205      memp_free(MEMP_ND6_QUEUE, q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2206    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2207  #else /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2208    if (neighbor_cache[i].q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2209      /* Get ipv6 header. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2210      ip6hdr = (struct ip6_hdr *)(neighbor_cache[i].q->payload);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2211      /* Create an aligned copy. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2212      ip6_addr_copy_from_packed(dest, ip6hdr->dest);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2213      /* Restore the zone, if applicable. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2214      ip6_addr_assign_zone(&dest, IP6_UNKNOWN, neighbor_cache[i].netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2215      /* send the queued IPv6 packet */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2216      (neighbor_cache[i].netif)->output_ip6(neighbor_cache[i].netif, neighbor_cache[i].q, &dest);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2217      /* free the queued IP packet */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2218      pbuf_free(neighbor_cache[i].q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2219      neighbor_cache[i].q = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2220    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2221  #endif /* LWIP_ND6_QUEUEING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2222  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2223  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2224  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2225   * A packet is to be transmitted to a specific IPv6 destination on a specific
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2226   * interface. Check if we can find the hardware address of the next hop to use
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2227   * for the packet. If so, give the hardware address to the caller, which should
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2228   * use it to send the packet right away. Otherwise, enqueue the packet for
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2229   * later transmission while looking up the hardware address, if possible.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2230   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2231   * As such, this function returns one of three different possible results:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2232   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2233   * - ERR_OK with a non-NULL 'hwaddrp': the caller should send the packet now.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2234   * - ERR_OK with a NULL 'hwaddrp': the packet has been enqueued for later.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2235   * - not ERR_OK: something went wrong; forward the error upward in the stack.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2236   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2237   * @param netif The lwIP network interface on which the IP packet will be sent.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2238   * @param q The pbuf(s) containing the IP packet to be sent.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2239   * @param ip6addr The destination IPv6 address of the packet.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2240   * @param hwaddrp On success, filled with a pointer to a HW address or NULL (meaning
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2241   *        the packet has been queued).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2242   * @return
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2243   * - ERR_OK on success, ERR_RTE if no route was found for the packet,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2244   * or ERR_MEM if low memory conditions prohibit sending the packet at all.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2245   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2246  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2247  nd6_get_next_hop_addr_or_queue(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr, const u8_t **hwaddrp)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2248  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2249    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2250  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2251    /* Get next hop record. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2252    i = nd6_get_next_hop_entry(ip6addr, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2253    if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2254      /* failed to get a next hop neighbor record. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2255      return i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2256    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2257  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2258    /* Now that we have a destination record, send or queue the packet. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2259    if (neighbor_cache[i].state == ND6_STALE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2260      /* Switch to delay state. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2261      neighbor_cache[i].state = ND6_DELAY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2262      neighbor_cache[i].counter.delay_time = LWIP_ND6_DELAY_FIRST_PROBE_TIME / ND6_TMR_INTERVAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2263    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2264    /* @todo should we send or queue if PROBE? send for now, to let unicast NS pass. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2265    if ((neighbor_cache[i].state == ND6_REACHABLE) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2266        (neighbor_cache[i].state == ND6_DELAY) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2267        (neighbor_cache[i].state == ND6_PROBE)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2268  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2269      /* Tell the caller to send out the packet now. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2270      *hwaddrp = neighbor_cache[i].lladdr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2271      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2272    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2273  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2274    /* We should queue packet on this interface. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2275    *hwaddrp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2276    return nd6_queue_packet(i, q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2277  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2278  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2279  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2280  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2281   * Get the Path MTU for a destination.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2282   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2283   * @param ip6addr the destination address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2284   * @param netif the netif on which the packet will be sent
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2285   * @return the Path MTU, if known, or the netif default MTU
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2286   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2287  u16_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2288  nd6_get_destination_mtu(const ip6_addr_t *ip6addr, struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2289  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2290    s16_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2291  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2292    i = nd6_find_destination_cache_entry(ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2293    if (i >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2294      if (destination_cache[i].pmtu > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2295        return destination_cache[i].pmtu;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2296      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2297    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2298  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2299    if (netif != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2300      return netif_mtu6(netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2301    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2302  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2303    return 1280; /* Minimum MTU */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2304  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2305  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2306  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2307  #if LWIP_ND6_TCP_REACHABILITY_HINTS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2308  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2309   * Provide the Neighbor discovery process with a hint that a
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2310   * destination is reachable. Called by tcp_receive when ACKs are
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2311   * received or sent (as per RFC). This is useful to avoid sending
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2312   * NS messages every 30 seconds.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2313   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2314   * @param ip6addr the destination address which is know to be reachable
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2315   *                by an upper layer protocol (TCP)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2316   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2317  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2318  nd6_reachability_hint(const ip6_addr_t *ip6addr)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2319  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2320    s8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2321    s16_t dst_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2322  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2323    /* Find destination in cache. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2324    if (ip6_addr_cmp(ip6addr, &(destination_cache[nd6_cached_destination_index].destination_addr))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2325      dst_idx = nd6_cached_destination_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2326      ND6_STATS_INC(nd6.cachehit);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2327    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2328      dst_idx = nd6_find_destination_cache_entry(ip6addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2329    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2330    if (dst_idx < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2331      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2332    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2333  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2334    /* Find next hop neighbor in cache. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2335    if (ip6_addr_cmp(&(destination_cache[dst_idx].next_hop_addr), &(neighbor_cache[nd6_cached_neighbor_index].next_hop_address))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2336      i = nd6_cached_neighbor_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2337      ND6_STATS_INC(nd6.cachehit);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2338    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2339      i = nd6_find_neighbor_cache_entry(&(destination_cache[dst_idx].next_hop_addr));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2340    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2341    if (i < 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2342      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2343    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2344  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2345    /* For safety: don't set as reachable if we don't have a LL address yet. Misuse protection. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2346    if (neighbor_cache[i].state == ND6_INCOMPLETE || neighbor_cache[i].state == ND6_NO_ENTRY) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2347      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2348    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2349  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2350    /* Set reachability state. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2351    neighbor_cache[i].state = ND6_REACHABLE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2352    neighbor_cache[i].counter.reachable_time = reachable_time;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2353  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2354  #endif /* LWIP_ND6_TCP_REACHABILITY_HINTS */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2355  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2356  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2357   * Remove all prefix, neighbor_cache and router entries of the specified netif.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2358   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2359   * @param netif points to a network interface
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2360   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2361  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2362  nd6_cleanup_netif(struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2363  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2364    u8_t i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2365    s8_t router_index;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2366    for (i = 0; i < LWIP_ND6_NUM_PREFIXES; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2367      if (prefix_list[i].netif == netif) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2368        prefix_list[i].netif = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2369      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2370    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2371    for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2372      if (neighbor_cache[i].netif == netif) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2373        for (router_index = 0; router_index < LWIP_ND6_NUM_ROUTERS; router_index++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2374          if (default_router_list[router_index].neighbor_entry == &neighbor_cache[i]) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2375            default_router_list[router_index].neighbor_entry = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2376            default_router_list[router_index].flags = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2377          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2378        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2379        neighbor_cache[i].isrouter = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2380        nd6_free_neighbor_cache_entry(i);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2381      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2382    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2383    /* Clear the destination cache, since many entries may now have become
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2384     * invalid for one of several reasons. As destination cache entries have no
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2385     * netif association, use a sledgehammer approach (this can be improved). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2386    nd6_clear_destination_cache();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2387  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2388  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2389  #if LWIP_IPV6_MLD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2390  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2391   * The state of a local IPv6 address entry is about to change. If needed, join
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2392   * or leave the solicited-node multicast group for the address.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2393   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2394   * @param netif The netif that owns the address.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2395   * @param addr_idx The index of the address.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2396   * @param new_state The new (IP6_ADDR_) state for the address.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2397   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2398  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2399  nd6_adjust_mld_membership(struct netif *netif, s8_t addr_idx, u8_t new_state)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2400  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2401    u8_t old_state, old_member, new_member;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2402  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2403    old_state = netif_ip6_addr_state(netif, addr_idx);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2404  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2405    /* Determine whether we were, and should be, a member of the solicited-node
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2406     * multicast group for this address. For tentative addresses, the group is
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2407     * not joined until the address enters the TENTATIVE_1 (or VALID) state. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2408    old_member = (old_state != IP6_ADDR_INVALID && old_state != IP6_ADDR_DUPLICATED && old_state != IP6_ADDR_TENTATIVE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2409    new_member = (new_state != IP6_ADDR_INVALID && new_state != IP6_ADDR_DUPLICATED && new_state != IP6_ADDR_TENTATIVE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2410  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2411    if (old_member != new_member) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2412      ip6_addr_set_solicitednode(&multicast_address, netif_ip6_addr(netif, addr_idx)->addr[3]);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2413      ip6_addr_assign_zone(&multicast_address, IP6_MULTICAST, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2414  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2415      if (new_member) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2416        mld6_joingroup_netif(netif, &multicast_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2417      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2418        mld6_leavegroup_netif(netif, &multicast_address);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2419      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2420    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2421  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2422  #endif /* LWIP_IPV6_MLD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2423  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2424  /** Netif was added, set up, or reconnected (link up) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2425  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2426  nd6_restart_netif(struct netif *netif)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2427  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2428  #if LWIP_IPV6_SEND_ROUTER_SOLICIT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2429    /* Send Router Solicitation messages (see RFC 4861, ch. 6.3.7). */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2430    netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2431  #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2432  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2433  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\core\ipv6\nd6.c	  2434  #endif /* LWIP_IPV6 */

	; Module end
