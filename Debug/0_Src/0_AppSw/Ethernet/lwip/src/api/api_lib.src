	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.3r1 Build 19041558 SN 09003382"
	.compiler_invocation	"ctc --dep-file=0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\.api_lib.o.d --fp-model=c,l,f,z,n,r,S,T -D__CPU__=tc39x -D__CPU_TC39X__ --core=tc1.6.2 --iso=99 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv4 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\arpa -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\net -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\sys -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\stdc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\apps -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\priv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Dp83825i -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Rtl8211f -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\UART -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Icu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmBc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\TimerWithTrigger -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\TPwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSpansion -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSt -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Dram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Sram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc\\Adc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce\\Crc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12\\IncrEnc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\In -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Trig -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hspdm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hspdm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Driver -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiMaster -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiSlave -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Emmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Sd -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Spu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Spu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\UART -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv4 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\arpa -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\net -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\sys -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\stdc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\apps -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\priv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Dp83825i -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -g2 --make-target=0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_lib.o -t4 --language=-gcc,-volatile,+strings,-kanji --default-near-size=8 -O2 --default-a1-size=0 --default-a0-size=0 --source --align=0 --compact-max-size=200 --switch=auto --error-limit=42 -o 0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_lib.src ..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_lib.c"
	.compiler_name		"ctc"
	;source	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_lib.c'

	
$TC162
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	731
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_lib.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\Debug\\',0,12,1
	.word	.L5
	.byte	2
	.byte	'int',0,4,5,3
	.word	168
	.byte	4
	.byte	'__c11_atomic_thread_fence',0,1,1,1,1,5
	.word	175
	.byte	0,2
	.byte	'unsigned int',0,4,7,6
	.word	217
	.byte	7
	.word	217
	.byte	8
	.byte	'__cmpswapw',0
	.word	233
	.byte	1,1,1,1,9
	.byte	'p',0
	.word	238
	.byte	9
	.byte	'value',0
	.word	217
	.byte	9
	.byte	'compare',0
	.word	217
	.byte	0,2
	.byte	'short int',0,2,5,10
	.byte	'__wchar_t',0,1,1,1
	.word	295
	.byte	10
	.byte	'__size_t',0,1,1,1
	.word	217
	.byte	10
	.byte	'__ptrdiff_t',0,1,1,1
	.word	168
	.byte	11,1,7
	.word	363
	.byte	10
	.byte	'__codeptr',0,1,1,1
	.word	365
	.byte	10
	.byte	'__intptr_t',0,1,1,1
	.word	168
	.byte	10
	.byte	'__uintptr_t',0,1,1,1
	.word	217
	.byte	2
	.byte	'unsigned char',0,1,8,10
	.byte	'uint8',0,2,108,29
	.word	427
	.byte	2
	.byte	'unsigned short int',0,2,7,10
	.byte	'uint16',0,2,112,29
	.word	458
	.byte	2
	.byte	'unsigned long int',0,4,7,10
	.byte	'uint32',0,2,116,29
	.word	495
	.byte	2
	.byte	'char',0,1,6,10
	.byte	'sint8',0,2,125,29
	.word	531
	.byte	10
	.byte	'sint16',0,2,129,1,29
	.word	295
	.byte	2
	.byte	'long int',0,4,5,10
	.byte	'sint32',0,2,134,1,29
	.word	569
	.byte	2
	.byte	'long long int',0,8,5,10
	.byte	'sint64',0,2,141,1,29
	.word	597
	.byte	2
	.byte	'float',0,4,4,10
	.byte	'float32',0,2,170,1,29
	.word	630
	.byte	12
	.byte	'void',0,7
	.word	656
	.byte	10
	.byte	'pvoid',0,3,54,28
	.word	662
	.byte	10
	.byte	'Ifx_TickTime',0,3,76,28
	.word	597
	.byte	10
	.byte	'u32_t',0,4,87,16
	.word	495
	.byte	10
	.byte	'intmax_t',0,5,198,2,41
	.word	597
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,38,0,73,19,0,0,4,46,1,3,8,54
	.byte	15,39,12,63,12,60,12,0,0,5,5,0,73,19,0,0,6,53,0,73,19,0,0,7,15,0,73,19,0,0,8,46,1,3,8,73,19,54,15,39,12
	.byte	63,12,60,12,0,0,9,5,0,3,8,73,19,0,0,10,22,0,3,8,58,15,59,15,57,15,73,19,0,0,11,21,0,54,15,0,0,12,59,0
	.byte	3,8,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L7-.L6
.L6:
	.half	3
	.word	.L9-.L8
.L8:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch',0
	.byte	'D:\\App\\Tasking6_3_Install\\ctc\\include\\',0,0
	.byte	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_lib.c',0,0,0,0
	.byte	'Platform_Types.h',0,1,0,0
	.byte	'Ifx_Types.h',0,1,0,0
	.byte	'cc.h',0,2,0,0
	.byte	'stdint.h',0,3,0,0,0
.L9:
.L7:

; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     1  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     2   * @file
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     3   * Sequential API External module
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     4   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     5   * @defgroup netconn Netconn API
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     6   * @ingroup sequential_api
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     7   * Thread-safe, to be called from non-TCPIP threads only.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     8   * TX/RX handling based on @ref netbuf (containing @ref pbuf)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	     9   * to avoid copying data around.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    10   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    11   * @defgroup netconn_common Common functions
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    12   * @ingroup netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    13   * For use with TCP and UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    14   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    15   * @defgroup netconn_tcp TCP only
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    16   * @ingroup netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    17   * TCP only functions
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    18   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    19   * @defgroup netconn_udp UDP only
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    20   * @ingroup netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    21   * UDP only functions
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    22   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    23  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    24  /*
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    25   * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    26   * All rights reserved.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    27   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    28   * Redistribution and use in source and binary forms, with or without modification,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    29   * are permitted provided that the following conditions are met:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    30   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    31   * 1. Redistributions of source code must retain the above copyright notice,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    32   *    this list of conditions and the following disclaimer.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    33   * 2. Redistributions in binary form must reproduce the above copyright notice,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    34   *    this list of conditions and the following disclaimer in the documentation
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    35   *    and/or other materials provided with the distribution.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    36   * 3. The name of the author may not be used to endorse or promote products
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    37   *    derived from this software without specific prior written permission.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    38   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    39   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    40   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    41   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    42   * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    43   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    44   * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    45   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    46   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    47   * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    48   * OF SUCH DAMAGE.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    49   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    50   * This file is part of the lwIP TCP/IP stack.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    51   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    52   * Author: Adam Dunkels <adam@sics.se>
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    53   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    54  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    55  /* This is the part of the API that is linked with
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    56     the application */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    57  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    58  #include "lwip/opt.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    59  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    60  #if LWIP_NETCONN /* don't build if not configured for use in lwipopts.h */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    61  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    62  #include "lwip/api.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    63  #include "lwip/memp.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    64  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    65  #include "lwip/ip.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    66  #include "lwip/raw.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    67  #include "lwip/udp.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    68  #include "lwip/priv/api_msg.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    69  #include "lwip/priv/tcp_priv.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    70  #include "lwip/priv/tcpip_priv.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    71  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    72  #ifdef LWIP_HOOK_FILENAME
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    73  #include LWIP_HOOK_FILENAME
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    74  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    75  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    76  #include <string.h>
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    77  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    78  #define API_MSG_VAR_REF(name)               API_VAR_REF(name)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    79  #define API_MSG_VAR_DECLARE(name)           API_VAR_DECLARE(struct api_msg, name)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    80  #define API_MSG_VAR_ALLOC(name)             API_VAR_ALLOC(struct api_msg, MEMP_API_MSG, name, ERR_MEM)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    81  #define API_MSG_VAR_ALLOC_RETURN_NULL(name) API_VAR_ALLOC(struct api_msg, MEMP_API_MSG, name, NULL)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    82  #define API_MSG_VAR_FREE(name)              API_VAR_FREE(MEMP_API_MSG, name)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    83  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    84  #if TCP_LISTEN_BACKLOG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    85  /* need to allocate API message for accept so empty message pool does not result in event loss
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    86   * see bug #47512: MPU_COMPATIBLE may fail on empty pool */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    87  #define API_MSG_VAR_ALLOC_ACCEPT(msg) API_MSG_VAR_ALLOC(msg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    88  #define API_MSG_VAR_FREE_ACCEPT(msg) API_MSG_VAR_FREE(msg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    89  #else /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    90  #define API_MSG_VAR_ALLOC_ACCEPT(msg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    91  #define API_MSG_VAR_FREE_ACCEPT(msg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    92  #endif /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    93  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    94  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    95  #define NETCONN_RECVMBOX_WAITABLE(conn) (sys_mbox_valid(&(conn)->recvmbox) && (((conn)->flags & NETCONN_FLAG_MBOXINVALID) == 0))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    96  #define NETCONN_ACCEPTMBOX_WAITABLE(conn) (sys_mbox_valid(&(conn)->acceptmbox) && (((conn)->flags & (NETCONN_FLAG_MBOXCLOSED|NETCONN_FLAG_MBOXINVALID)) == 0))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    97  #define NETCONN_MBOX_WAITING_INC(conn) SYS_ARCH_INC(conn->mbox_threads_waiting, 1)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    98  #define NETCONN_MBOX_WAITING_DEC(conn) SYS_ARCH_DEC(conn->mbox_threads_waiting, 1)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	    99  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   100  #define NETCONN_RECVMBOX_WAITABLE(conn)   sys_mbox_valid(&(conn)->recvmbox)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   101  #define NETCONN_ACCEPTMBOX_WAITABLE(conn) (sys_mbox_valid(&(conn)->acceptmbox) && (((conn)->flags & NETCONN_FLAG_MBOXCLOSED) == 0))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   102  #define NETCONN_MBOX_WAITING_INC(conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   103  #define NETCONN_MBOX_WAITING_DEC(conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   104  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   105  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   106  static err_t netconn_close_shutdown(struct netconn *conn, u8_t how);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   107  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   108  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   109   * Call the lower part of a netconn_* function
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   110   * This function is then running in the thread context
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   111   * of tcpip_thread and has exclusive access to lwIP core code.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   112   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   113   * @param fn function to call
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   114   * @param apimsg a struct containing the function to call and its parameters
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   115   * @return ERR_OK if the function was called, another err_t if not
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   116   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   117  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   118  netconn_apimsg(tcpip_callback_fn fn, struct api_msg *apimsg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   119  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   120    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   121  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   122  #ifdef LWIP_DEBUG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   123    /* catch functions that don't set err */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   124    apimsg->err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   125  #endif /* LWIP_DEBUG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   126  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   127  #if LWIP_NETCONN_SEM_PER_THREAD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   128    apimsg->op_completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   129  #endif /* LWIP_NETCONN_SEM_PER_THREAD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   130  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   131    err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   132    if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   133      return apimsg->err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   134    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   135    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   136  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   137  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   138  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   139   * Create a new netconn (of a specific type) that has a callback function.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   140   * The corresponding pcb is also created.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   141   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   142   * @param t the type of 'connection' to create (@see enum netconn_type)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   143   * @param proto the IP protocol for RAW IP pcbs
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   144   * @param callback a function to call on status changes (RX available, TX'ed)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   145   * @return a newly allocated struct netconn or
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   146   *         NULL on memory error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   147   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   148  struct netconn *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   149  netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   150  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   151    struct netconn *conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   152    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   153    API_MSG_VAR_ALLOC_RETURN_NULL(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   154  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   155    conn = netconn_alloc(t, callback);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   156    if (conn != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   157      err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   158  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   159      API_MSG_VAR_REF(msg).msg.n.proto = proto;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   160      API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   161      err = netconn_apimsg(lwip_netconn_do_newconn, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   162      if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   163        LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   164        LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   165  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   166        LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   167  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   168  #if !LWIP_NETCONN_SEM_PER_THREAD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   169        LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   170        sys_sem_free(&conn->op_completed);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   171  #endif /* !LWIP_NETCONN_SEM_PER_THREAD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   172        sys_mbox_free(&conn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   173        memp_free(MEMP_NETCONN, conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   174        API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   175        return NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   176      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   177    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   178    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   179    return conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   180  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   181  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   182  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   183   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   184   * Close a netconn 'connection' and free all its resources but not the netconn itself.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   185   * UDP and RAW connection are completely closed, TCP pcbs might still be in a waitstate
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   186   * after this returns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   187   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   188   * @param conn the netconn to delete
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   189   * @return ERR_OK if the connection was deleted
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   190   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   191  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   192  netconn_prepare_delete(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   193  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   194    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   195    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   196  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   197    /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   198    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   199      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   200    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   201  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   202    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   203    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   204  #if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   205    /* get the time we started, which is later compared to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   206       sys_now() + conn->send_timeout */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   207    API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   208  #else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   209  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   210    API_MSG_VAR_REF(msg).msg.sd.polls_left =
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   211      ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   212  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   213  #endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   214    err = netconn_apimsg(lwip_netconn_do_delconn, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   215    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   216  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   217    if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   218      return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   219    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   220    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   221  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   222  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   223  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   224   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   225   * Close a netconn 'connection' and free its resources.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   226   * UDP and RAW connection are completely closed, TCP pcbs might still be in a waitstate
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   227   * after this returns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   228   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   229   * @param conn the netconn to delete
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   230   * @return ERR_OK if the connection was deleted
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   231   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   232  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   233  netconn_delete(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   234  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   235    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   236  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   237    /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   238    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   239      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   240    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   241  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   242  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   243    if (conn->flags & NETCONN_FLAG_MBOXINVALID) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   244      /* Already called netconn_prepare_delete() before */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   245      err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   246    } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   247  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   248    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   249      err = netconn_prepare_delete(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   250    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   251    if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   252      netconn_free(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   253    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   254    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   255  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   256  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   257  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   258   * Get the local or remote IP address and port of a netconn.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   259   * For RAW netconns, this returns the protocol instead of a port!
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   260   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   261   * @param conn the netconn to query
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   262   * @param addr a pointer to which to save the IP address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   263   * @param port a pointer to which to save the port (or protocol for RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   264   * @param local 1 to get the local IP address, 0 to get the remote one
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   265   * @return ERR_CONN for invalid connections
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   266   *         ERR_OK if the information was retrieved
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   267   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   268  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   269  netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   270  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   271    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   272    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   273  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   274    LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   275    LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   276    LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   277  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   278    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   279    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   280    API_MSG_VAR_REF(msg).msg.ad.local = local;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   281  #if LWIP_MPU_COMPATIBLE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   282    err = netconn_apimsg(lwip_netconn_do_getaddr, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   283    *addr = msg->msg.ad.ipaddr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   284    *port = msg->msg.ad.port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   285  #else /* LWIP_MPU_COMPATIBLE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   286    msg.msg.ad.ipaddr = addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   287    msg.msg.ad.port = port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   288    err = netconn_apimsg(lwip_netconn_do_getaddr, &msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   289  #endif /* LWIP_MPU_COMPATIBLE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   290    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   291  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   292    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   293  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   294  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   295  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   296   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   297   * Bind a netconn to a specific local IP address and port.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   298   * Binding one netconn twice might not always be checked correctly!
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   299   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   300   * @param conn the netconn to bind
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   301   * @param addr the local IP address to bind the netconn to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   302   *             (use IP4_ADDR_ANY/IP6_ADDR_ANY to bind to all addresses)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   303   * @param port the local port to bind the netconn to (not used for RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   304   * @return ERR_OK if bound, any other err_t on failure
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   305   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   306  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   307  netconn_bind(struct netconn *conn, const ip_addr_t *addr, u16_t port)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   308  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   309    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   310    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   311  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   312    LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   313  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   314  #if LWIP_IPV4
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   315    /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   316    if (addr == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   317      addr = IP4_ADDR_ANY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   318    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   319  #endif /* LWIP_IPV4 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   320  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   321  #if LWIP_IPV4 && LWIP_IPV6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   322    /* "Socket API like" dual-stack support: If IP to bind to is IP6_ADDR_ANY,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   323     * and NETCONN_FLAG_IPV6_V6ONLY is 0, use IP_ANY_TYPE to bind
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   324     */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   325    if ((netconn_get_ipv6only(conn) == 0) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   326        ip_addr_cmp(addr, IP6_ADDR_ANY)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   327      addr = IP_ANY_TYPE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   328    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   329  #endif /* LWIP_IPV4 && LWIP_IPV6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   330  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   331    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   332    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   333    API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   334    API_MSG_VAR_REF(msg).msg.bc.port = port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   335    err = netconn_apimsg(lwip_netconn_do_bind, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   336    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   337  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   338    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   339  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   340  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   341  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   342   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   343   * Bind a netconn to a specific interface and port.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   344   * Binding one netconn twice might not always be checked correctly!
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   345   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   346   * @param conn the netconn to bind
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   347   * @param if_idx the local interface index to bind the netconn to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   348   * @return ERR_OK if bound, any other err_t on failure
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   349   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   350  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   351  netconn_bind_if(struct netconn *conn, u8_t if_idx)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   352  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   353    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   354    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   355  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   356    LWIP_ERROR("netconn_bind_if: invalid conn", (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   357  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   358    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   359    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   360    API_MSG_VAR_REF(msg).msg.bc.if_idx = if_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   361    err = netconn_apimsg(lwip_netconn_do_bind_if, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   362    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   363  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   364    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   365  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   366  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   367  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   368   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   369   * Connect a netconn to a specific remote IP address and port.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   370   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   371   * @param conn the netconn to connect
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   372   * @param addr the remote IP address to connect to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   373   * @param port the remote port to connect to (no used for RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   374   * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   375   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   376  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   377  netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   378  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   379    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   380    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   381  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   382    LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   383  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   384  #if LWIP_IPV4
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   385    /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   386    if (addr == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   387      addr = IP4_ADDR_ANY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   388    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   389  #endif /* LWIP_IPV4 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   390  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   391    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   392    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   393    API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   394    API_MSG_VAR_REF(msg).msg.bc.port = port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   395    err = netconn_apimsg(lwip_netconn_do_connect, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   396    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   397  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   398    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   399  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   400  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   401  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   402   * @ingroup netconn_udp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   403   * Disconnect a netconn from its current peer (only valid for UDP netconns).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   404   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   405   * @param conn the netconn to disconnect
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   406   * @return See @ref err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   407   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   408  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   409  netconn_disconnect(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   410  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   411    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   412    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   413  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   414    LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   415  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   416    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   417    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   418    err = netconn_apimsg(lwip_netconn_do_disconnect, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   419    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   420  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   421    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   422  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   423  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   424  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   425   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   426   * Set a TCP netconn into listen mode
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   427   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   428   * @param conn the tcp netconn to set to listen mode
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   429   * @param backlog the listen backlog, only used if TCP_LISTEN_BACKLOG==1
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   430   * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   431   *         don't return any error (yet?))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   432   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   433  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   434  netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   435  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   436  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   437    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   438    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   439  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   440    /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   441    LWIP_UNUSED_ARG(backlog);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   442  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   443    LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   444  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   445    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   446    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   447  #if TCP_LISTEN_BACKLOG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   448    API_MSG_VAR_REF(msg).msg.lb.backlog = backlog;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   449  #endif /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   450    err = netconn_apimsg(lwip_netconn_do_listen, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   451    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   452  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   453    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   454  #else /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   455    LWIP_UNUSED_ARG(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   456    LWIP_UNUSED_ARG(backlog);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   457    return ERR_ARG;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   458  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   459  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   460  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   461  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   462   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   463   * Accept a new connection on a TCP listening netconn.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   464   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   465   * @param conn the TCP listen netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   466   * @param new_conn pointer where the new connection is stored
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   467   * @return ERR_OK if a new connection has been received or an error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   468   *                code otherwise
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   469   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   470  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   471  netconn_accept(struct netconn *conn, struct netconn **new_conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   472  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   473  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   474    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   475    void *accept_ptr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   476    struct netconn *newconn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   477  #if TCP_LISTEN_BACKLOG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   478    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   479  #endif /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   480  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   481    LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   482    *new_conn = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   483    LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   484  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   485    /* NOTE: Although the opengroup spec says a pending error shall be returned to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   486             send/recv/getsockopt(SO_ERROR) only, we return it for listening
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   487             connections also, to handle embedded-system errors */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   488    err = netconn_err(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   489    if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   490      /* return pending error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   491      return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   492    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   493    if (!NETCONN_ACCEPTMBOX_WAITABLE(conn)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   494      /* don't accept if closed: this might block the application task
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   495         waiting on acceptmbox forever! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   496      return ERR_CLSD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   497    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   498  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   499    API_MSG_VAR_ALLOC_ACCEPT(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   500  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   501    NETCONN_MBOX_WAITING_INC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   502    if (netconn_is_nonblocking(conn)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   503      if (sys_arch_mbox_tryfetch(&conn->acceptmbox, &accept_ptr) == SYS_ARCH_TIMEOUT) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   504        API_MSG_VAR_FREE_ACCEPT(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   505        NETCONN_MBOX_WAITING_DEC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   506        return ERR_WOULDBLOCK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   507      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   508    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   509  #if LWIP_SO_RCVTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   510      if (sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   511        API_MSG_VAR_FREE_ACCEPT(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   512        NETCONN_MBOX_WAITING_DEC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   513        return ERR_TIMEOUT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   514      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   515  #else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   516      sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   517  #endif /* LWIP_SO_RCVTIMEO*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   518    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   519    NETCONN_MBOX_WAITING_DEC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   520  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   521    if (conn->flags & NETCONN_FLAG_MBOXINVALID) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   522      if (lwip_netconn_is_deallocated_msg(accept_ptr)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   523        /* the netconn has been closed from another thread */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   524        API_MSG_VAR_FREE_ACCEPT(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   525        return ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   526      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   527    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   528  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   529  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   530    /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   531    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   532  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   533    if (lwip_netconn_is_err_msg(accept_ptr, &err)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   534      /* a connection has been aborted: e.g. out of pcbs or out of netconns during accept */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   535      API_MSG_VAR_FREE_ACCEPT(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   536      return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   537    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   538    if (accept_ptr == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   539      /* connection has been aborted */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   540      API_MSG_VAR_FREE_ACCEPT(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   541      return ERR_CLSD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   542    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   543    newconn = (struct netconn *)accept_ptr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   544  #if TCP_LISTEN_BACKLOG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   545    /* Let the stack know that we have accepted the connection. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   546    API_MSG_VAR_REF(msg).conn = newconn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   547    /* don't care for the return value of lwip_netconn_do_recv */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   548    netconn_apimsg(lwip_netconn_do_accepted, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   549    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   550  #endif /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   551  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   552    *new_conn = newconn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   553    /* don't set conn->last_err: it's only ERR_OK, anyway */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   554    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   555  #else /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   556    LWIP_UNUSED_ARG(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   557    LWIP_UNUSED_ARG(new_conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   558    return ERR_ARG;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   559  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   560  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   561  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   562  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   563   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   564   * Receive data: actual implementation that doesn't care whether pbuf or netbuf
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   565   * is received (this is internal, it's just here for describing common errors)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   566   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   567   * @param conn the netconn from which to receive data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   568   * @param new_buf pointer where a new pbuf/netbuf is stored when received data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   569   * @param apiflags flags that control function behaviour. For now only:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   570   * - NETCONN_DONTBLOCK: only read data that is available now, don't wait for more data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   571   * @return ERR_OK if data has been received, an error code otherwise (timeout,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   572   *                memory error or another error)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   573   *         ERR_CONN if not connected
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   574   *         ERR_CLSD if TCP connection has been closed
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   575   *         ERR_WOULDBLOCK if the netconn is nonblocking but would block to wait for data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   576   *         ERR_TIMEOUT if the netconn has a receive timeout and no data was received
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   577   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   578  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   579  netconn_recv_data(struct netconn *conn, void **new_buf, u8_t apiflags)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   580  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   581    void *buf = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   582    u16_t len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   583  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   584    LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   585    *new_buf = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   586    LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   587  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   588    if (!NETCONN_RECVMBOX_WAITABLE(conn)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   589      err_t err = netconn_err(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   590      if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   591        /* return pending error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   592        return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   593      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   594      return ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   595    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   596  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   597    NETCONN_MBOX_WAITING_INC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   598    if (netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   599        (conn->flags & NETCONN_FLAG_MBOXCLOSED) || (conn->pending_err != ERR_OK)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   600      if (sys_arch_mbox_tryfetch(&conn->recvmbox, &buf) == SYS_ARCH_TIMEOUT) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   601        err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   602        NETCONN_MBOX_WAITING_DEC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   603        err = netconn_err(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   604        if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   605          /* return pending error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   606          return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   607        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   608        if (conn->flags & NETCONN_FLAG_MBOXCLOSED) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   609          return ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   610        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   611        return ERR_WOULDBLOCK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   612      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   613    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   614  #if LWIP_SO_RCVTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   615      if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   616        NETCONN_MBOX_WAITING_DEC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   617        return ERR_TIMEOUT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   618      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   619  #else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   620      sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   621  #endif /* LWIP_SO_RCVTIMEO*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   622    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   623    NETCONN_MBOX_WAITING_DEC(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   624  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   625    if (conn->flags & NETCONN_FLAG_MBOXINVALID) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   626      if (lwip_netconn_is_deallocated_msg(buf)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   627        /* the netconn has been closed from another thread */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   628        API_MSG_VAR_FREE_ACCEPT(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   629        return ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   630      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   631    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   632  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   633  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   634  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   635  #if (LWIP_UDP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   636    if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   637  #endif /* (LWIP_UDP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   638    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   639      err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   640      /* Check if this is an error message or a pbuf */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   641      if (lwip_netconn_is_err_msg(buf, &err)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   642        /* new_buf has been zeroed above already */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   643        if (err == ERR_CLSD) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   644          /* connection closed translates to ERR_OK with *new_buf == NULL */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   645          return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   646        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   647        return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   648      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   649      len = ((struct pbuf *)buf)->tot_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   650    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   651  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   652  #if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   653    else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   654  #endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   655  #if (LWIP_UDP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   656    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   657      LWIP_ASSERT("buf != NULL", buf != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   658      len = netbuf_len((struct netbuf *)buf);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   659    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   660  #endif /* (LWIP_UDP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   661  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   662  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   663    SYS_ARCH_DEC(conn->recv_avail, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   664  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   665    /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   666    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   667  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   668    LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   669  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   670    *new_buf = buf;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   671    /* don't set conn->last_err: it's only ERR_OK, anyway */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   672    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   673  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   674  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   675  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   676  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   677  netconn_tcp_recvd_msg(struct netconn *conn, size_t len, struct api_msg *msg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   678  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   679    LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   680               NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   681  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   682    msg->conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   683    msg->msg.r.len = len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   684  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   685    return netconn_apimsg(lwip_netconn_do_recv, msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   686  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   687  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   688  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   689  netconn_tcp_recvd(struct netconn *conn, size_t len)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   690  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   691    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   692    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   693    LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   694               NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   695  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   696    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   697    err = netconn_tcp_recvd_msg(conn, len, &API_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   698    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   699    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   700  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   701  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   702  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   703  netconn_recv_data_tcp(struct netconn *conn, struct pbuf **new_buf, u8_t apiflags)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   704  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   705    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   706    struct pbuf *buf;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   707    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   708  #if LWIP_MPU_COMPATIBLE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   709    msg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   710  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   711  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   712    if (!NETCONN_RECVMBOX_WAITABLE(conn)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   713      /* This only happens when calling this function more than once *after* receiving FIN */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   714      return ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   715    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   716    if (netconn_is_flag_set(conn, NETCONN_FIN_RX_PENDING)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   717      netconn_clear_flags(conn, NETCONN_FIN_RX_PENDING);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   718      goto handle_fin;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   719    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   720  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   721    if (!(apiflags & NETCONN_NOAUTORCVD)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   722      /* need to allocate API message here so empty message pool does not result in event loss
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   723        * see bug #47512: MPU_COMPATIBLE may fail on empty pool */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   724      API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   725    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   726  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   727    err = netconn_recv_data(conn, (void **)new_buf, apiflags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   728    if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   729      if (!(apiflags & NETCONN_NOAUTORCVD)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   730        API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   731      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   732      return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   733    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   734    buf = *new_buf;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   735    if (!(apiflags & NETCONN_NOAUTORCVD)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   736      /* Let the stack know that we have taken the data. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   737      u16_t len = buf ? buf->tot_len : 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   738      /* don't care for the return value of lwip_netconn_do_recv */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   739      /* @todo: this should really be fixed, e.g. by retrying in poll on error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   740      netconn_tcp_recvd_msg(conn, len,  &API_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   741      API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   742    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   743  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   744    /* If we are closed, we indicate that we no longer wish to use the socket */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   745    if (buf == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   746      if (apiflags & NETCONN_NOFIN) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   747        /* received a FIN but the caller cannot handle it right now:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   748           re-enqueue it and return "no data" */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   749        netconn_set_flags(conn, NETCONN_FIN_RX_PENDING);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   750        return ERR_WOULDBLOCK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   751      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   752  handle_fin:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   753        API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   754        if (conn->pcb.ip == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   755          /* race condition: RST during recv */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   756          err = netconn_err(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   757          if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   758            return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   759          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   760          return ERR_RST;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   761        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   762        /* RX side is closed, so deallocate the recvmbox */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   763        netconn_close_shutdown(conn, NETCONN_SHUT_RD);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   764        /* Don' store ERR_CLSD as conn->err since we are only half-closed */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   765        return ERR_CLSD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   766      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   767    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   768    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   769  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   770  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   771  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   772   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   773   * Receive data (in form of a pbuf) from a TCP netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   774   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   775   * @param conn the netconn from which to receive data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   776   * @param new_buf pointer where a new pbuf is stored when received data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   777   * @return ERR_OK if data has been received, an error code otherwise (timeout,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   778   *                memory error or another error, @see netconn_recv_data)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   779   *         ERR_ARG if conn is not a TCP netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   780   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   781  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   782  netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   783  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   784    LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   785               NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   786  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   787    return netconn_recv_data_tcp(conn, new_buf, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   788  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   789  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   790  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   791   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   792   * Receive data (in form of a pbuf) from a TCP netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   793   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   794   * @param conn the netconn from which to receive data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   795   * @param new_buf pointer where a new pbuf is stored when received data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   796   * @param apiflags flags that control function behaviour. For now only:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   797   * - NETCONN_DONTBLOCK: only read data that is available now, don't wait for more data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   798   * @return ERR_OK if data has been received, an error code otherwise (timeout,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   799   *                memory error or another error, @see netconn_recv_data)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   800   *         ERR_ARG if conn is not a TCP netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   801   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   802  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   803  netconn_recv_tcp_pbuf_flags(struct netconn *conn, struct pbuf **new_buf, u8_t apiflags)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   804  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   805    LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   806               NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   807  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   808    return netconn_recv_data_tcp(conn, new_buf, apiflags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   809  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   810  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   811  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   812  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   813   * Receive data (in form of a netbuf) from a UDP or RAW netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   814   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   815   * @param conn the netconn from which to receive data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   816   * @param new_buf pointer where a new netbuf is stored when received data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   817   * @return ERR_OK if data has been received, an error code otherwise (timeout,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   818   *                memory error or another error)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   819   *         ERR_ARG if conn is not a UDP/RAW netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   820   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   821  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   822  netconn_recv_udp_raw_netbuf(struct netconn *conn, struct netbuf **new_buf)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   823  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   824    LWIP_ERROR("netconn_recv_udp_raw_netbuf: invalid conn", (conn != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   825               NETCONNTYPE_GROUP(netconn_type(conn)) != NETCONN_TCP, return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   826  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   827    return netconn_recv_data(conn, (void **)new_buf, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   828  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   829  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   830  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   831   * Receive data (in form of a netbuf) from a UDP or RAW netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   832   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   833   * @param conn the netconn from which to receive data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   834   * @param new_buf pointer where a new netbuf is stored when received data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   835   * @param apiflags flags that control function behaviour. For now only:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   836   * - NETCONN_DONTBLOCK: only read data that is available now, don't wait for more data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   837   * @return ERR_OK if data has been received, an error code otherwise (timeout,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   838   *                memory error or another error)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   839   *         ERR_ARG if conn is not a UDP/RAW netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   840   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   841  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   842  netconn_recv_udp_raw_netbuf_flags(struct netconn *conn, struct netbuf **new_buf, u8_t apiflags)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   843  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   844    LWIP_ERROR("netconn_recv_udp_raw_netbuf: invalid conn", (conn != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   845               NETCONNTYPE_GROUP(netconn_type(conn)) != NETCONN_TCP, return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   846  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   847    return netconn_recv_data(conn, (void **)new_buf, apiflags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   848  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   849  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   850  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   851   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   852   * Receive data (in form of a netbuf containing a packet buffer) from a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   853   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   854   * @param conn the netconn from which to receive data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   855   * @param new_buf pointer where a new netbuf is stored when received data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   856   * @return ERR_OK if data has been received, an error code otherwise (timeout,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   857   *                memory error or another error)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   858   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   859  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   860  netconn_recv(struct netconn *conn, struct netbuf **new_buf)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   861  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   862  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   863    struct netbuf *buf = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   864    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   865  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   866  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   867    LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   868    *new_buf = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   869    LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   870  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   871  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   872  #if (LWIP_UDP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   873    if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   874  #endif /* (LWIP_UDP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   875    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   876      struct pbuf *p = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   877      /* This is not a listening netconn, since recvmbox is set */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   878  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   879      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   880      if (buf == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   881        return ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   882      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   883  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   884      err = netconn_recv_data_tcp(conn, &p, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   885      if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   886        memp_free(MEMP_NETBUF, buf);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   887        return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   888      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   889      LWIP_ASSERT("p != NULL", p != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   890  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   891      buf->p = p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   892      buf->ptr = p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   893      buf->port = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   894      ip_addr_set_zero(&buf->addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   895      *new_buf = buf;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   896      /* don't set conn->last_err: it's only ERR_OK, anyway */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   897      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   898    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   899  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   900  #if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   901    else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   902  #endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   903    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   904  #if (LWIP_UDP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   905      return netconn_recv_data(conn, (void **)new_buf, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   906  #endif /* (LWIP_UDP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   907    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   908  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   909  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   910  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   911   * @ingroup netconn_udp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   912   * Send data (in form of a netbuf) to a specific remote IP address and port.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   913   * Only to be used for UDP and RAW netconns (not TCP).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   914   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   915   * @param conn the netconn over which to send data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   916   * @param buf a netbuf containing the data to send
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   917   * @param addr the remote IP address to which to send the data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   918   * @param port the remote port to which to send the data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   919   * @return ERR_OK if data was sent, any other err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   920   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   921  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   922  netconn_sendto(struct netconn *conn, struct netbuf *buf, const ip_addr_t *addr, u16_t port)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   923  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   924    if (buf != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   925      ip_addr_set(&buf->addr, addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   926      buf->port = port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   927      return netconn_send(conn, buf);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   928    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   929    return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   930  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   931  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   932  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   933   * @ingroup netconn_udp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   934   * Send data over a UDP or RAW netconn (that is already connected).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   935   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   936   * @param conn the UDP or RAW netconn over which to send data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   937   * @param buf a netbuf containing the data to send
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   938   * @return ERR_OK if data was sent, any other err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   939   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   940  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   941  netconn_send(struct netconn *conn, struct netbuf *buf)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   942  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   943    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   944    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   945  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   946    LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   947  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   948    LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   949  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   950    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   951    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   952    API_MSG_VAR_REF(msg).msg.b = buf;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   953    err = netconn_apimsg(lwip_netconn_do_send, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   954    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   955  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   956    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   957  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   958  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   959  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   960   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   961   * Send data over a TCP netconn.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   962   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   963   * @param conn the TCP netconn over which to send data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   964   * @param dataptr pointer to the application buffer that contains the data to send
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   965   * @param size size of the application data to send
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   966   * @param apiflags combination of following flags :
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   967   * - NETCONN_COPY: data will be copied into memory belonging to the stack
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   968   * - NETCONN_MORE: for TCP connection, PSH flag will be set on last segment sent
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   969   * - NETCONN_DONTBLOCK: only write the data if all data can be written at once
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   970   * @param bytes_written pointer to a location that receives the number of written bytes
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   971   * @return ERR_OK if data was sent, any other err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   972   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   973  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   974  netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   975                       u8_t apiflags, size_t *bytes_written)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   976  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   977    struct netvector vector;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   978    vector.ptr = dataptr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   979    vector.len = size;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   980    return netconn_write_vectors_partly(conn, &vector, 1, apiflags, bytes_written);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   981  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   982  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   983  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   984   * Send vectorized data atomically over a TCP netconn.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   985   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   986   * @param conn the TCP netconn over which to send data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   987   * @param vectors array of vectors containing data to send
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   988   * @param vectorcnt number of vectors in the array
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   989   * @param apiflags combination of following flags :
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   990   * - NETCONN_COPY: data will be copied into memory belonging to the stack
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   991   * - NETCONN_MORE: for TCP connection, PSH flag will be set on last segment sent
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   992   * - NETCONN_DONTBLOCK: only write the data if all data can be written at once
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   993   * @param bytes_written pointer to a location that receives the number of written bytes
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   994   * @return ERR_OK if data was sent, any other err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   995   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   996  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   997  netconn_write_vectors_partly(struct netconn *conn, struct netvector *vectors, u16_t vectorcnt,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   998                               u8_t apiflags, size_t *bytes_written)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	   999  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1000    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1001    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1002    u8_t dontblock;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1003    size_t size;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1004    int i;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1005  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1006    LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1007    LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP), return ERR_VAL;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1008    dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1009  #if LWIP_SO_SNDTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1010    if (conn->send_timeout != 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1011      dontblock = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1012    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1013  #endif /* LWIP_SO_SNDTIMEO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1014    if (dontblock && !bytes_written) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1015      /* This implies netconn_write() cannot be used for non-blocking send, since
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1016         it has no way to return the number of bytes written. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1017      return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1018    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1019  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1020    /* sum up the total size */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1021    size = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1022    for (i = 0; i < vectorcnt; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1023      size += vectors[i].len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1024      if (size < vectors[i].len) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1025        /* overflow */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1026        return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1027      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1028    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1029    if (size == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1030      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1031    } else if (size > SSIZE_MAX) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1032      ssize_t limited;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1033      /* this is required by the socket layer (cannot send full size_t range) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1034      if (!bytes_written) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1035        return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1036      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1037      /* limit the amount of data to send */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1038      limited = SSIZE_MAX;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1039      size = (size_t)limited;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1040    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1041  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1042    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1043    /* non-blocking write sends as much  */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1044    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1045    API_MSG_VAR_REF(msg).msg.w.vector = vectors;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1046    API_MSG_VAR_REF(msg).msg.w.vector_cnt = vectorcnt;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1047    API_MSG_VAR_REF(msg).msg.w.vector_off = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1048    API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1049    API_MSG_VAR_REF(msg).msg.w.len = size;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1050    API_MSG_VAR_REF(msg).msg.w.offset = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1051  #if LWIP_SO_SNDTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1052    if (conn->send_timeout != 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1053      /* get the time we started, which is later compared to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1054          sys_now() + conn->send_timeout */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1055      API_MSG_VAR_REF(msg).msg.w.time_started = sys_now();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1056    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1057      API_MSG_VAR_REF(msg).msg.w.time_started = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1058    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1059  #endif /* LWIP_SO_SNDTIMEO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1060  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1061    /* For locking the core: this _can_ be delayed on low memory/low send buffer,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1062       but if it is, this is done inside api_msg.c:do_write(), so we can use the
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1063       non-blocking version here. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1064    err = netconn_apimsg(lwip_netconn_do_write, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1065    if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1066      if (bytes_written != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1067        *bytes_written = API_MSG_VAR_REF(msg).msg.w.offset;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1068      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1069      /* for blocking, check all requested bytes were written, NOTE: send_timeout is
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1070         treated as dontblock (see dontblock assignment above) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1071      if (!dontblock) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1072        LWIP_ASSERT("do_write failed to write all bytes", API_MSG_VAR_REF(msg).msg.w.offset == size);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1073      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1074    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1075    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1076  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1077    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1078  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1079  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1080  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1081   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1082   * Close or shutdown a TCP netconn (doesn't delete it).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1083   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1084   * @param conn the TCP netconn to close or shutdown
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1085   * @param how fully close or only shutdown one side?
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1086   * @return ERR_OK if the netconn was closed, any other err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1087   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1088  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1089  netconn_close_shutdown(struct netconn *conn, u8_t how)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1090  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1091    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1092    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1093    LWIP_UNUSED_ARG(how);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1094  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1095    LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1096  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1097    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1098    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1099  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1100    /* shutting down both ends is the same as closing */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1101    API_MSG_VAR_REF(msg).msg.sd.shut = how;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1102  #if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1103    /* get the time we started, which is later compared to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1104       sys_now() + conn->send_timeout */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1105    API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1106  #else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1107    API_MSG_VAR_REF(msg).msg.sd.polls_left =
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1108      ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1109  #endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1110  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1111    err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1112    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1113  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1114    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1115  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1116  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1117  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1118   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1119   * Close a TCP netconn (doesn't delete it).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1120   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1121   * @param conn the TCP netconn to close
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1122   * @return ERR_OK if the netconn was closed, any other err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1123   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1124  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1125  netconn_close(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1126  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1127    /* shutting down both ends is the same as closing */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1128    return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1129  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1130  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1131  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1132   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1133   * Get and reset pending error on a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1134   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1135   * @param conn the netconn to get the error from
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1136   * @return and pending error or ERR_OK if no error was pending
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1137   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1138  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1139  netconn_err(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1140  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1141    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1142    SYS_ARCH_DECL_PROTECT(lev);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1143    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1144      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1145    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1146    SYS_ARCH_PROTECT(lev);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1147    err = conn->pending_err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1148    conn->pending_err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1149    SYS_ARCH_UNPROTECT(lev);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1150    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1151  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1152  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1153  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1154   * @ingroup netconn_tcp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1155   * Shut down one or both sides of a TCP netconn (doesn't delete it).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1156   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1157   * @param conn the TCP netconn to shut down
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1158   * @param shut_rx shut down the RX side (no more read possible after this)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1159   * @param shut_tx shut down the TX side (no more write possible after this)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1160   * @return ERR_OK if the netconn was closed, any other err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1161   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1162  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1163  netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1164  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1165    return netconn_close_shutdown(conn, (u8_t)((shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1166  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1167  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1168  #if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1169  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1170   * @ingroup netconn_udp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1171   * Join multicast groups for UDP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1172   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1173   * @param conn the UDP netconn for which to change multicast addresses
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1174   * @param multiaddr IP address of the multicast group to join or leave
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1175   * @param netif_addr the IP address of the network interface on which to send
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1176   *                  the igmp message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1177   * @param join_or_leave flag whether to send a join- or leave-message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1178   * @return ERR_OK if the action was taken, any err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1179   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1180  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1181  netconn_join_leave_group(struct netconn *conn,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1182                           const ip_addr_t *multiaddr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1183                           const ip_addr_t *netif_addr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1184                           enum netconn_igmp join_or_leave)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1185  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1186    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1187    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1188  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1189    LWIP_ERROR("netconn_join_leave_group: invalid conn",  (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1190  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1191    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1192  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1193  #if LWIP_IPV4
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1194    /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1195    if (multiaddr == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1196      multiaddr = IP4_ADDR_ANY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1197    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1198    if (netif_addr == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1199      netif_addr = IP4_ADDR_ANY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1200    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1201  #endif /* LWIP_IPV4 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1202  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1203    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1204    API_MSG_VAR_REF(msg).msg.jl.multiaddr = API_MSG_VAR_REF(multiaddr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1205    API_MSG_VAR_REF(msg).msg.jl.netif_addr = API_MSG_VAR_REF(netif_addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1206    API_MSG_VAR_REF(msg).msg.jl.join_or_leave = join_or_leave;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1207    err = netconn_apimsg(lwip_netconn_do_join_leave_group, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1208    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1209  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1210    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1211  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1212  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1213   * @ingroup netconn_udp
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1214   * Join multicast groups for UDP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1215   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1216   * @param conn the UDP netconn for which to change multicast addresses
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1217   * @param multiaddr IP address of the multicast group to join or leave
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1218   * @param if_idx the index of the netif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1219   * @param join_or_leave flag whether to send a join- or leave-message
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1220   * @return ERR_OK if the action was taken, any err_t on error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1221   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1222  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1223  netconn_join_leave_group_netif(struct netconn *conn,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1224                                 const ip_addr_t *multiaddr,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1225                                 u8_t if_idx,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1226                                 enum netconn_igmp join_or_leave)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1227  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1228    API_MSG_VAR_DECLARE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1229    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1230  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1231    LWIP_ERROR("netconn_join_leave_group: invalid conn",  (conn != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1232  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1233    API_MSG_VAR_ALLOC(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1234  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1235  #if LWIP_IPV4
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1236    /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1237    if (multiaddr == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1238      multiaddr = IP4_ADDR_ANY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1239    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1240    if (if_idx == NETIF_NO_INDEX) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1241      return ERR_IF;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1242    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1243  #endif /* LWIP_IPV4 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1244  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1245    API_MSG_VAR_REF(msg).conn = conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1246    API_MSG_VAR_REF(msg).msg.jl.multiaddr = API_MSG_VAR_REF(multiaddr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1247    API_MSG_VAR_REF(msg).msg.jl.if_idx = if_idx;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1248    API_MSG_VAR_REF(msg).msg.jl.join_or_leave = join_or_leave;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1249    err = netconn_apimsg(lwip_netconn_do_join_leave_group_netif, &API_MSG_VAR_REF(msg));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1250    API_MSG_VAR_FREE(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1251  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1252    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1253  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1254  #endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1255  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1256  #if LWIP_DNS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1257  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1258   * @ingroup netconn_common
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1259   * Execute a DNS query, only one IP address is returned
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1260   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1261   * @param name a string representation of the DNS host name to query
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1262   * @param addr a preallocated ip_addr_t where to store the resolved IP address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1263   * @param dns_addrtype IP address type (IPv4 / IPv6)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1264   * @return ERR_OK: resolving succeeded
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1265   *         ERR_MEM: memory error, try again later
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1266   *         ERR_ARG: dns client not initialized or invalid hostname
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1267   *         ERR_VAL: dns server response was invalid
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1268   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1269  #if LWIP_IPV4 && LWIP_IPV6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1270  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1271  netconn_gethostbyname_addrtype(const char *name, ip_addr_t *addr, u8_t dns_addrtype)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1272  #else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1273  err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1274  netconn_gethostbyname(const char *name, ip_addr_t *addr)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1275  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1276  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1277    API_VAR_DECLARE(struct dns_api_msg, msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1278  #if !LWIP_MPU_COMPATIBLE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1279    sys_sem_t sem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1280  #endif /* LWIP_MPU_COMPATIBLE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1281    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1282    err_t cberr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1283  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1284    LWIP_ERROR("netconn_gethostbyname: invalid name", (name != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1285    LWIP_ERROR("netconn_gethostbyname: invalid addr", (addr != NULL), return ERR_ARG;);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1286  #if LWIP_MPU_COMPATIBLE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1287    if (strlen(name) >= DNS_MAX_NAME_LENGTH) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1288      return ERR_ARG;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1289    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1290  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1291  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1292  #ifdef LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1293  #if LWIP_IPV4 && LWIP_IPV6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1294    if (LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE(name, addr, dns_addrtype, &err)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1295  #else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1296    if (LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE(name, addr, NETCONN_DNS_DEFAULT, &err)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1297  #endif /* LWIP_IPV4 && LWIP_IPV6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1298      return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1299    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1300  #endif /* LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1301  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1302    API_VAR_ALLOC(struct dns_api_msg, MEMP_DNS_API_MSG, msg, ERR_MEM);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1303  #if LWIP_MPU_COMPATIBLE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1304    strncpy(API_VAR_REF(msg).name, name, DNS_MAX_NAME_LENGTH - 1);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1305    API_VAR_REF(msg).name[DNS_MAX_NAME_LENGTH - 1] = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1306  #else /* LWIP_MPU_COMPATIBLE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1307    msg.err = &err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1308    msg.sem = &sem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1309    API_VAR_REF(msg).addr = API_VAR_REF(addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1310    API_VAR_REF(msg).name = name;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1311  #endif /* LWIP_MPU_COMPATIBLE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1312  #if LWIP_IPV4 && LWIP_IPV6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1313    API_VAR_REF(msg).dns_addrtype = dns_addrtype;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1314  #endif /* LWIP_IPV4 && LWIP_IPV6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1315  #if LWIP_NETCONN_SEM_PER_THREAD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1316    API_VAR_REF(msg).sem = LWIP_NETCONN_THREAD_SEM_GET();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1317  #else /* LWIP_NETCONN_SEM_PER_THREAD*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1318    err = sys_sem_new(API_EXPR_REF(API_VAR_REF(msg).sem), 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1319    if (err != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1320      API_VAR_FREE(MEMP_DNS_API_MSG, msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1321      return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1322    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1323  #endif /* LWIP_NETCONN_SEM_PER_THREAD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1324  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1325    cberr = tcpip_send_msg_wait_sem(lwip_netconn_do_gethostbyname, &API_VAR_REF(msg), API_EXPR_REF(API_VAR_REF(msg).sem));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1326  #if !LWIP_NETCONN_SEM_PER_THREAD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1327    sys_sem_free(API_EXPR_REF(API_VAR_REF(msg).sem));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1328  #endif /* !LWIP_NETCONN_SEM_PER_THREAD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1329    if (cberr != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1330      API_VAR_FREE(MEMP_DNS_API_MSG, msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1331      return cberr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1332    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1333  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1334  #if LWIP_MPU_COMPATIBLE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1335    *addr = msg->addr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1336    err = msg->err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1337  #endif /* LWIP_MPU_COMPATIBLE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1338  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1339    API_VAR_FREE(MEMP_DNS_API_MSG, msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1340    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1341  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1342  #endif /* LWIP_DNS*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1343  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1344  #if LWIP_NETCONN_SEM_PER_THREAD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1345  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1346  netconn_thread_init(void)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1347  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1348    sys_sem_t *sem = LWIP_NETCONN_THREAD_SEM_GET();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1349    if ((sem == NULL) || !sys_sem_valid(sem)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1350      /* call alloc only once */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1351      LWIP_NETCONN_THREAD_SEM_ALLOC();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1352      LWIP_ASSERT("LWIP_NETCONN_THREAD_SEM_ALLOC() failed", sys_sem_valid(LWIP_NETCONN_THREAD_SEM_GET()));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1353    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1354  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1355  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1356  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1357  netconn_thread_cleanup(void)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1358  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1359    sys_sem_t *sem = LWIP_NETCONN_THREAD_SEM_GET();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1360    if ((sem != NULL) && sys_sem_valid(sem)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1361      /* call free only once */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1362      LWIP_NETCONN_THREAD_SEM_FREE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1363    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1364  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1365  #endif /* LWIP_NETCONN_SEM_PER_THREAD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1366  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_lib.c	  1367  #endif /* LWIP_NETCONN */

	; Module end
