	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.3r1 Build 19041558 SN 09003382"
	.compiler_invocation	"ctc --dep-file=0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\.api_msg.o.d --fp-model=c,l,f,z,n,r,S,T -D__CPU__=tc39x -D__CPU_TC39X__ --core=tc1.6.2 --iso=99 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv4 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\arpa -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\net -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\sys -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\stdc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\apps -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\priv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Dp83825i -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Rtl8211f -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\UART -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Icu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmBc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\TimerWithTrigger -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6\\TPwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSpansion -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSt -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Dram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Sram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ebu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc\\Adc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce\\Crc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12\\IncrEnc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\In -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm\\Trig -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hspdm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hspdm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Driver -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiMaster -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiSlave -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Rif\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Emmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Sd -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Spu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Spu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\UART -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv4 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\core\\ipv6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\arpa -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\net -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\posix\\sys -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\compat\\stdc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\apps -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\priv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\lwip\\prot -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\include\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\netif\\ppp\\polarssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\Phy_Dp83825i -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\_Reg -g2 --make-target=0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_msg.o -t4 --language=-gcc,-volatile,+strings,-kanji --default-near-size=8 -O2 --default-a1-size=0 --default-a0-size=0 --source --align=0 --compact-max-size=200 --switch=auto --error-limit=42 -o 0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_msg.src ..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_msg.c"
	.compiler_name		"ctc"
	;source	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_msg.c'

	
$TC162
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	731
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_msg.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\Debug\\',0,12,1
	.word	.L5
	.byte	2
	.byte	'int',0,4,5,3
	.word	168
	.byte	4
	.byte	'__c11_atomic_thread_fence',0,1,1,1,1,5
	.word	175
	.byte	0,2
	.byte	'unsigned int',0,4,7,6
	.word	217
	.byte	7
	.word	217
	.byte	8
	.byte	'__cmpswapw',0
	.word	233
	.byte	1,1,1,1,9
	.byte	'p',0
	.word	238
	.byte	9
	.byte	'value',0
	.word	217
	.byte	9
	.byte	'compare',0
	.word	217
	.byte	0,2
	.byte	'short int',0,2,5,10
	.byte	'__wchar_t',0,1,1,1
	.word	295
	.byte	10
	.byte	'__size_t',0,1,1,1
	.word	217
	.byte	10
	.byte	'__ptrdiff_t',0,1,1,1
	.word	168
	.byte	11,1,7
	.word	363
	.byte	10
	.byte	'__codeptr',0,1,1,1
	.word	365
	.byte	10
	.byte	'__intptr_t',0,1,1,1
	.word	168
	.byte	10
	.byte	'__uintptr_t',0,1,1,1
	.word	217
	.byte	2
	.byte	'unsigned char',0,1,8,10
	.byte	'uint8',0,2,108,29
	.word	427
	.byte	2
	.byte	'unsigned short int',0,2,7,10
	.byte	'uint16',0,2,112,29
	.word	458
	.byte	2
	.byte	'unsigned long int',0,4,7,10
	.byte	'uint32',0,2,116,29
	.word	495
	.byte	2
	.byte	'char',0,1,6,10
	.byte	'sint8',0,2,125,29
	.word	531
	.byte	10
	.byte	'sint16',0,2,129,1,29
	.word	295
	.byte	2
	.byte	'long int',0,4,5,10
	.byte	'sint32',0,2,134,1,29
	.word	569
	.byte	2
	.byte	'long long int',0,8,5,10
	.byte	'sint64',0,2,141,1,29
	.word	597
	.byte	2
	.byte	'float',0,4,4,10
	.byte	'float32',0,2,170,1,29
	.word	630
	.byte	12
	.byte	'void',0,7
	.word	656
	.byte	10
	.byte	'pvoid',0,3,54,28
	.word	662
	.byte	10
	.byte	'Ifx_TickTime',0,3,76,28
	.word	597
	.byte	10
	.byte	'u32_t',0,4,87,16
	.word	495
	.byte	10
	.byte	'intmax_t',0,5,198,2,41
	.word	597
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,38,0,73,19,0,0,4,46,1,3,8,54
	.byte	15,39,12,63,12,60,12,0,0,5,5,0,73,19,0,0,6,53,0,73,19,0,0,7,15,0,73,19,0,0,8,46,1,3,8,73,19,54,15,39,12
	.byte	63,12,60,12,0,0,9,5,0,3,8,73,19,0,0,10,22,0,3,8,58,15,59,15,57,15,73,19,0,0,11,21,0,54,15,0,0,12,59,0
	.byte	3,8,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L7-.L6
.L6:
	.half	3
	.word	.L9-.L8
.L8:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\4_McHal\\Tricore\\Cpu\\Std',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_Client_Ethernet\\0_Src\\0_AppSw\\Ethernet\\lwip\\port\\include\\arch',0
	.byte	'D:\\App\\Tasking6_3_Install\\ctc\\include\\',0,0
	.byte	'..\\0_Src\\0_AppSw\\Ethernet\\lwip\\src\\api\\api_msg.c',0,0,0,0
	.byte	'Platform_Types.h',0,1,0,0
	.byte	'Ifx_Types.h',0,1,0,0
	.byte	'cc.h',0,2,0,0
	.byte	'stdint.h',0,3,0,0,0
.L9:
.L7:

; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     1  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     2   * @file
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     3   * Sequential API Internal module
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     4   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     5   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     6  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     7  /*
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     8   * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	     9   * All rights reserved.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    10   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    11   * Redistribution and use in source and binary forms, with or without modification,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    12   * are permitted provided that the following conditions are met:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    13   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    14   * 1. Redistributions of source code must retain the above copyright notice,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    15   *    this list of conditions and the following disclaimer.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    16   * 2. Redistributions in binary form must reproduce the above copyright notice,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    17   *    this list of conditions and the following disclaimer in the documentation
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    18   *    and/or other materials provided with the distribution.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    19   * 3. The name of the author may not be used to endorse or promote products
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    20   *    derived from this software without specific prior written permission.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    21   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    22   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    23   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    24   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    25   * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    26   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    27   * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    28   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    29   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    30   * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    31   * OF SUCH DAMAGE.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    32   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    33   * This file is part of the lwIP TCP/IP stack.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    34   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    35   * Author: Adam Dunkels <adam@sics.se>
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    36   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    37   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    38  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    39  #include "lwip/opt.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    40  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    41  #if LWIP_NETCONN /* don't build if not configured for use in lwipopts.h */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    42  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    43  #include "lwip/priv/api_msg.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    44  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    45  #include "lwip/ip.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    46  #include "lwip/ip_addr.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    47  #include "lwip/udp.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    48  #include "lwip/tcp.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    49  #include "lwip/raw.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    50  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    51  #include "lwip/memp.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    52  #include "lwip/igmp.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    53  #include "lwip/dns.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    54  #include "lwip/mld6.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    55  #include "lwip/priv/tcpip_priv.h"
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    56  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    57  #include <string.h>
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    58  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    59  /* netconns are polled once per second (e.g. continue write on memory error) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    60  #define NETCONN_TCP_POLL_INTERVAL 2
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    61  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    62  #define SET_NONBLOCKING_CONNECT(conn, val)  do { if (val) { \ 
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    63    netconn_set_flags(conn, NETCONN_FLAG_IN_NONBLOCKING_CONNECT); \ 
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    64  } else { \ 
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    65    netconn_clear_flags(conn, NETCONN_FLAG_IN_NONBLOCKING_CONNECT); }} while(0)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    66  #define IN_NONBLOCKING_CONNECT(conn) netconn_is_flag_set(conn, NETCONN_FLAG_IN_NONBLOCKING_CONNECT)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    67  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    68  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    69  #define NETCONN_MBOX_VALID(conn, mbox) (sys_mbox_valid(mbox) && ((conn->flags & NETCONN_FLAG_MBOXINVALID) == 0))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    70  #else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    71  #define NETCONN_MBOX_VALID(conn, mbox) sys_mbox_valid(mbox)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    72  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    73  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    74  /* forward declarations */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    75  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    76  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    77  #define WRITE_DELAYED         , 1
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    78  #define WRITE_DELAYED_PARAM   , u8_t delayed
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    79  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    80  #define WRITE_DELAYED
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    81  #define WRITE_DELAYED_PARAM
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    82  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    83  static err_t lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    84  static err_t lwip_netconn_do_close_internal(struct netconn *conn  WRITE_DELAYED_PARAM);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    85  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    86  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    87  static void netconn_drain(struct netconn *conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    88  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    89  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    90  #define TCPIP_APIMSG_ACK(m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    91  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    92  #define TCPIP_APIMSG_ACK(m)   do { sys_sem_signal(LWIP_API_MSG_SEM(m)); } while(0)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    93  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    94  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    95  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    96  const u8_t netconn_deleted = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    97  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    98  int
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	    99  lwip_netconn_is_deallocated_msg(void *msg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   100  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   101    if (msg == &netconn_deleted) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   102      return 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   103    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   104    return 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   105  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   106  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   107  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   108  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   109  const u8_t netconn_aborted = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   110  const u8_t netconn_reset = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   111  const u8_t netconn_closed = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   112  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   113  /** Translate an error to a unique void* passed via an mbox */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   114  static void *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   115  lwip_netconn_err_to_msg(err_t err)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   116  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   117    switch (err) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   118      case ERR_ABRT:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   119        return LWIP_CONST_CAST(void *, &netconn_aborted);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   120      case ERR_RST:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   121        return LWIP_CONST_CAST(void *, &netconn_reset);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   122      case ERR_CLSD:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   123        return LWIP_CONST_CAST(void *, &netconn_closed);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   124      default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   125        LWIP_ASSERT("unhandled error", err == ERR_OK);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   126        return NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   127    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   128  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   129  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   130  int
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   131  lwip_netconn_is_err_msg(void *msg, err_t *err)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   132  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   133    LWIP_ASSERT("err != NULL", err != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   134  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   135    if (msg == &netconn_aborted) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   136      *err = ERR_ABRT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   137      return 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   138    } else if (msg == &netconn_reset) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   139      *err = ERR_RST;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   140      return 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   141    } else if (msg == &netconn_closed) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   142      *err = ERR_CLSD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   143      return 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   144    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   145    return 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   146  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   147  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   148  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   149  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   150  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   151  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   152   * Receive callback function for RAW netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   153   * Doesn't 'eat' the packet, only copies it and sends it to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   154   * conn->recvmbox
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   155   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   156   * @see raw.h (struct raw_pcb.recv) for parameters and return value
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   157   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   158  static u8_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   159  recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   160           const ip_addr_t *addr)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   161  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   162    struct pbuf *q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   163    struct netbuf *buf;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   164    struct netconn *conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   165  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   166    LWIP_UNUSED_ARG(addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   167    conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   168  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   169    if ((conn != NULL) && NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   170  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   171      int recv_avail;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   172      SYS_ARCH_GET(conn->recv_avail, recv_avail);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   173      if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   174        return 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   175      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   176  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   177      /* copy the whole packet into new pbufs */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   178      q = pbuf_clone(PBUF_RAW, PBUF_RAM, p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   179      if (q != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   180        u16_t len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   181        buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   182        if (buf == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   183          pbuf_free(q);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   184          return 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   185        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   186  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   187        buf->p = q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   188        buf->ptr = q;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   189        ip_addr_copy(buf->addr, *ip_current_src_addr());
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   190        buf->port = pcb->protocol;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   191  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   192        len = q->tot_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   193        if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   194          netbuf_delete(buf);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   195          return 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   196        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   197  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   198          SYS_ARCH_INC(conn->recv_avail, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   199  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   200          /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   201          API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   202        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   203      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   204    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   205  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   206    return 0; /* do not eat the packet */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   207  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   208  #endif /* LWIP_RAW*/
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   209  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   210  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   211  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   212   * Receive callback function for UDP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   213   * Posts the packet to conn->recvmbox or deletes it on memory error.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   214   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   215   * @see udp.h (struct udp_pcb.recv) for parameters
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   216   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   217  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   218  recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   219           const ip_addr_t *addr, u16_t port)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   220  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   221    struct netbuf *buf;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   222    struct netconn *conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   223    u16_t len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   224  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   225    int recv_avail;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   226  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   227  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   228    LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   229    LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   230    LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   231    conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   232  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   233    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   234      pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   235      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   236    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   237  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   238    LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   239  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   240  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   241    SYS_ARCH_GET(conn->recv_avail, recv_avail);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   242    if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   243        ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   244  #else  /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   245    if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   246  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   247      pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   248      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   249    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   250  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   251    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   252    if (buf == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   253      pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   254      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   255    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   256      buf->p = p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   257      buf->ptr = p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   258      ip_addr_set(&buf->addr, addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   259      buf->port = port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   260  #if LWIP_NETBUF_RECVINFO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   261      if (conn->flags & NETCONN_FLAG_PKTINFO) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   262        /* get the UDP header - always in the first pbuf, ensured by udp_input */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   263        const struct udp_hdr *udphdr = (const struct udp_hdr *)ip_next_header_ptr();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   264        buf->flags = NETBUF_FLAG_DESTADDR;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   265        ip_addr_set(&buf->toaddr, ip_current_dest_addr());
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   266        buf->toport_chksum = udphdr->dest;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   267      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   268  #endif /* LWIP_NETBUF_RECVINFO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   269    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   270  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   271    len = p->tot_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   272    if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   273      netbuf_delete(buf);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   274      return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   275    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   276  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   277      SYS_ARCH_INC(conn->recv_avail, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   278  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   279      /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   280      API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   281    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   282  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   283  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   284  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   285  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   286  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   287   * Receive callback function for TCP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   288   * Posts the packet to conn->recvmbox, but doesn't delete it on errors.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   289   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   290   * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   291   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   292  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   293  recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   294  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   295    struct netconn *conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   296    u16_t len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   297    void *msg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   298  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   299    LWIP_UNUSED_ARG(pcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   300    LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   301    LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   302    LWIP_ASSERT("err != ERR_OK unhandled", err == ERR_OK);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   303    LWIP_UNUSED_ARG(err); /* for LWIP_NOASSERT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   304    conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   305  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   306    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   307      return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   308    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   309    LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   310  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   311    if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   312      /* recvmbox already deleted */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   313      if (p != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   314        tcp_recved(pcb, p->tot_len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   315        pbuf_free(p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   316      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   317      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   318    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   319    /* Unlike for UDP or RAW pcbs, don't check for available space
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   320       using recv_avail since that could break the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   321       (data is already ACKed) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   322  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   323    if (p != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   324      msg = p;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   325      len = p->tot_len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   326    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   327      msg = LWIP_CONST_CAST(void *, &netconn_closed);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   328      len = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   329    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   330  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   331    if (sys_mbox_trypost(&conn->recvmbox, msg) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   332      /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   333      return ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   334    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   335  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   336      SYS_ARCH_INC(conn->recv_avail, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   337  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   338      /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   339      API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   340    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   341  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   342    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   343  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   344  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   345  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   346   * Poll callback function for TCP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   347   * Wakes up an application thread that waits for a connection to close
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   348   * or data to be sent. The application thread then takes the
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   349   * appropriate action to go on.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   350   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   351   * Signals the conn->sem.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   352   * netconn_close waits for conn->sem if closing failed.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   353   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   354   * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   355   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   356  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   357  poll_tcp(void *arg, struct tcp_pcb *pcb)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   358  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   359    struct netconn *conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   360  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   361    LWIP_UNUSED_ARG(pcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   362    LWIP_ASSERT("conn != NULL", (conn != NULL));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   363  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   364    if (conn->state == NETCONN_WRITE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   365      lwip_netconn_do_writemore(conn  WRITE_DELAYED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   366    } else if (conn->state == NETCONN_CLOSE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   367  #if !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   368      if (conn->current_msg && conn->current_msg->msg.sd.polls_left) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   369        conn->current_msg->msg.sd.polls_left--;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   370      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   371  #endif /* !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   372      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   373    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   374    /* @todo: implement connect timeout here? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   375  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   376    /* Did a nonblocking write fail before? Then check available write-space. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   377    if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   378      /* If the queued byte- or pbuf-count drops below the configured low-water limit,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   379         let select mark this pcb as writable again. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   380      if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   381          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   382        netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   383        API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   384      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   385    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   386  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   387    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   388  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   389  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   390  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   391   * Sent callback function for TCP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   392   * Signals the conn->sem and calls API_EVENT.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   393   * netconn_write waits for conn->sem if send buffer is low.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   394   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   395   * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   396   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   397  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   398  sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   399  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   400    struct netconn *conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   401  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   402    LWIP_UNUSED_ARG(pcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   403    LWIP_ASSERT("conn != NULL", (conn != NULL));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   404  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   405    if (conn) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   406      if (conn->state == NETCONN_WRITE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   407        lwip_netconn_do_writemore(conn  WRITE_DELAYED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   408      } else if (conn->state == NETCONN_CLOSE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   409        lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   410      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   411  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   412      /* If the queued byte- or pbuf-count drops below the configured low-water limit,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   413         let select mark this pcb as writable again. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   414      if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   415          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   416        netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   417        API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   418      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   419    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   420  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   421    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   422  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   423  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   424  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   425   * Error callback function for TCP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   426   * Signals conn->sem, posts to all conn mboxes and calls API_EVENT.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   427   * The application thread has then to decide what to do.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   428   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   429   * @see tcp.h (struct tcp_pcb.err) for parameters
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   430   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   431  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   432  err_tcp(void *arg, err_t err)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   433  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   434    struct netconn *conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   435    enum netconn_state old_state;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   436    void *mbox_msg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   437    SYS_ARCH_DECL_PROTECT(lev);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   438  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   439    conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   440    LWIP_ASSERT("conn != NULL", (conn != NULL));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   441  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   442    SYS_ARCH_PROTECT(lev);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   443  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   444    /* when err is called, the pcb is deallocated, so delete the reference */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   445    conn->pcb.tcp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   446    /* store pending error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   447    conn->pending_err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   448    /* prevent application threads from blocking on 'recvmbox'/'acceptmbox' */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   449    conn->flags |= NETCONN_FLAG_MBOXCLOSED;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   450  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   451    /* reset conn->state now before waking up other threads */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   452    old_state = conn->state;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   453    conn->state = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   454  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   455    SYS_ARCH_UNPROTECT(lev);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   456  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   457    /* Notify the user layer about a connection error. Used to signal select. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   458    API_EVENT(conn, NETCONN_EVT_ERROR, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   459    /* Try to release selects pending on 'read' or 'write', too.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   460       They will get an error if they actually try to read or write. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   461    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   462    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   463  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   464    mbox_msg = lwip_netconn_err_to_msg(err);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   465    /* pass error message to recvmbox to wake up pending recv */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   466    if (NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   467      /* use trypost to prevent deadlock */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   468      sys_mbox_trypost(&conn->recvmbox, mbox_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   469    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   470    /* pass error message to acceptmbox to wake up pending accept */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   471    if (NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   472      /* use trypost to preven deadlock */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   473      sys_mbox_trypost(&conn->acceptmbox, mbox_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   474    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   475  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   476    if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   477        (old_state == NETCONN_CONNECT)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   478      /* calling lwip_netconn_do_writemore/lwip_netconn_do_close_internal is not necessary
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   479         since the pcb has already been deleted! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   480      int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   481      SET_NONBLOCKING_CONNECT(conn, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   482  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   483      if (!was_nonblocking_connect) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   484        sys_sem_t *op_completed_sem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   485        /* set error return code */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   486        LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   487        if (old_state == NETCONN_CLOSE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   488          /* let close succeed: the connection is closed after all... */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   489          conn->current_msg->err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   490        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   491          /* Write and connect fail */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   492          conn->current_msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   493        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   494        op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   495        LWIP_ASSERT("inavlid op_completed_sem", sys_sem_valid(op_completed_sem));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   496        conn->current_msg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   497        /* wake up the waiting task */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   498        sys_sem_signal(op_completed_sem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   499      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   500        /* @todo: test what happens for error on nonblocking connect */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   501      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   502    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   503      LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   504    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   505  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   506  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   507  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   508   * Setup a tcp_pcb with the correct callback function pointers
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   509   * and their arguments.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   510   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   511   * @param conn the TCP netconn to setup
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   512   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   513  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   514  setup_tcp(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   515  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   516    struct tcp_pcb *pcb;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   517  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   518    pcb = conn->pcb.tcp;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   519    tcp_arg(pcb, conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   520    tcp_recv(pcb, recv_tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   521    tcp_sent(pcb, sent_tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   522    tcp_poll(pcb, poll_tcp, NETCONN_TCP_POLL_INTERVAL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   523    tcp_err(pcb, err_tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   524  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   525  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   526  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   527   * Accept callback function for TCP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   528   * Allocates a new netconn and posts that to conn->acceptmbox.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   529   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   530   * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   531   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   532  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   533  accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   534  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   535    struct netconn *newconn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   536    struct netconn *conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   537  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   538    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   539      return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   540    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   541    if (!NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   542      LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   543      return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   544    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   545  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   546    if (newpcb == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   547      /* out-of-pcbs during connect: pass on this error to the application */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   548      if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   549        /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   550        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   551      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   552      return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   553    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   554    LWIP_ASSERT("expect newpcb == NULL or err == ERR_OK", err == ERR_OK);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   555    LWIP_UNUSED_ARG(err); /* for LWIP_NOASSERT */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   556  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   557    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->state: %s\n", tcp_debug_state_str(newpcb->state)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   558  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   559    /* We have to set the callback here even though
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   560     * the new socket is unknown. newconn->socket is marked as -1. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   561    newconn = netconn_alloc(conn->type, conn->callback);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   562    if (newconn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   563      /* outof netconns: pass on this error to the application */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   564      if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   565        /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   566        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   567      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   568      return ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   569    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   570    newconn->pcb.tcp = newpcb;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   571    setup_tcp(newconn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   572  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   573    /* handle backlog counter */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   574    tcp_backlog_delayed(newpcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   575  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   576    if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   577      /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   578         so do nothing here! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   579      /* remove all references to this netconn from the pcb */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   580      struct tcp_pcb *pcb = newconn->pcb.tcp;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   581      tcp_arg(pcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   582      tcp_recv(pcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   583      tcp_sent(pcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   584      tcp_poll(pcb, NULL, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   585      tcp_err(pcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   586      /* remove reference from to the pcb from this netconn */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   587      newconn->pcb.tcp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   588      /* no need to drain since we know the recvmbox is empty. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   589      sys_mbox_free(&newconn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   590      sys_mbox_set_invalid(&newconn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   591      netconn_free(newconn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   592      return ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   593    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   594      /* Register event with callback */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   595      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   596    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   597  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   598    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   599  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   600  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   601  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   602  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   603   * Create a new pcb of a specific type.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   604   * Called from lwip_netconn_do_newconn().
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   605   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   606   * @param msg the api_msg describing the connection type
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   607   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   608  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   609  pcb_new(struct api_msg *msg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   610  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   611    enum lwip_ip_addr_type iptype = IPADDR_TYPE_V4;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   612  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   613    LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   614  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   615  #if LWIP_IPV6 && LWIP_IPV4
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   616    /* IPv6: Dual-stack by default, unless netconn_set_ipv6only() is called */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   617    if (NETCONNTYPE_ISIPV6(netconn_type(msg->conn))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   618      iptype = IPADDR_TYPE_ANY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   619    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   620  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   621  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   622    /* Allocate a PCB for this connection */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   623    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   624  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   625      case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   626        msg->conn->pcb.raw = raw_new_ip_type(iptype, msg->msg.n.proto);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   627        if (msg->conn->pcb.raw != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   628  #if LWIP_IPV6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   629          /* ICMPv6 packets should always have checksum calculated by the stack as per RFC 3542 chapter 3.1 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   630          if (NETCONNTYPE_ISIPV6(msg->conn->type) && msg->conn->pcb.raw->protocol == IP6_NEXTH_ICMP6) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   631            msg->conn->pcb.raw->chksum_reqd = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   632            msg->conn->pcb.raw->chksum_offset = 2;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   633          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   634  #endif /* LWIP_IPV6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   635          raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   636        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   637        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   638  #endif /* LWIP_RAW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   639  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   640      case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   641        msg->conn->pcb.udp = udp_new_ip_type(iptype);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   642        if (msg->conn->pcb.udp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   643  #if LWIP_UDPLITE
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   644          if (NETCONNTYPE_ISUDPLITE(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   645            udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   646          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   647  #endif /* LWIP_UDPLITE */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   648          if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   649            udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   650          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   651          udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   652        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   653        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   654  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   655  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   656      case NETCONN_TCP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   657        msg->conn->pcb.tcp = tcp_new_ip_type(iptype);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   658        if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   659          setup_tcp(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   660        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   661        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   662  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   663      default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   664        /* Unsupported netconn type, e.g. protocol disabled */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   665        msg->err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   666        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   667    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   668    if (msg->conn->pcb.ip == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   669      msg->err = ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   670    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   671  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   672  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   673  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   674   * Create a new pcb of a specific type inside a netconn.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   675   * Called from netconn_new_with_proto_and_callback.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   676   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   677   * @param m the api_msg describing the connection type
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   678   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   679  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   680  lwip_netconn_do_newconn(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   681  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   682    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   683  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   684    msg->err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   685    if (msg->conn->pcb.tcp == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   686      pcb_new(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   687    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   688    /* Else? This "new" connection already has a PCB allocated. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   689    /* Is this an error condition? Should it be deleted? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   690    /* We currently just are happy and return. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   691  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   692    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   693  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   694  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   695  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   696   * Create a new netconn (of a specific type) that has a callback function.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   697   * The corresponding pcb is NOT created!
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   698   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   699   * @param t the type of 'connection' to create (@see enum netconn_type)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   700   * @param callback a function to call on status changes (RX available, TX'ed)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   701   * @return a newly allocated struct netconn or
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   702   *         NULL on memory error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   703   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   704  struct netconn *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   705  netconn_alloc(enum netconn_type t, netconn_callback callback)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   706  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   707    struct netconn *conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   708    int size;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   709    u8_t init_flags = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   710  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   711    conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   712    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   713      return NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   714    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   715  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   716    conn->pending_err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   717    conn->type = t;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   718    conn->pcb.tcp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   719  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   720    /* If all sizes are the same, every compiler should optimize this switch to nothing */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   721    switch (NETCONNTYPE_GROUP(t)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   722  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   723      case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   724        size = DEFAULT_RAW_RECVMBOX_SIZE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   725        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   726  #endif /* LWIP_RAW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   727  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   728      case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   729        size = DEFAULT_UDP_RECVMBOX_SIZE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   730  #if LWIP_NETBUF_RECVINFO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   731        init_flags |= NETCONN_FLAG_PKTINFO;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   732  #endif /* LWIP_NETBUF_RECVINFO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   733        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   734  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   735  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   736      case NETCONN_TCP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   737        size = DEFAULT_TCP_RECVMBOX_SIZE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   738        break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   739  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   740      default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   741        LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   742        goto free_and_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   743    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   744  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   745    if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   746      goto free_and_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   747    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   748  #if !LWIP_NETCONN_SEM_PER_THREAD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   749    if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   750      sys_mbox_free(&conn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   751      goto free_and_return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   752    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   753  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   754  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   755  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   756    sys_mbox_set_invalid(&conn->acceptmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   757  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   758    conn->state        = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   759  #if LWIP_SOCKET
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   760    /* initialize socket to -1 since 0 is a valid socket */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   761    conn->socket       = -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   762  #endif /* LWIP_SOCKET */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   763    conn->callback     = callback;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   764  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   765    conn->current_msg  = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   766  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   767  #if LWIP_SO_SNDTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   768    conn->send_timeout = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   769  #endif /* LWIP_SO_SNDTIMEO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   770  #if LWIP_SO_RCVTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   771    conn->recv_timeout = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   772  #endif /* LWIP_SO_RCVTIMEO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   773  #if LWIP_SO_RCVBUF
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   774    conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   775    conn->recv_avail   = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   776  #endif /* LWIP_SO_RCVBUF */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   777  #if LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   778    conn->linger = -1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   779  #endif /* LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   780    conn->flags = init_flags;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   781    return conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   782  free_and_return:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   783    memp_free(MEMP_NETCONN, conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   784    return NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   785  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   786  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   787  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   788   * Delete a netconn and all its resources.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   789   * The pcb is NOT freed (since we might not be in the right thread context do this).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   790   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   791   * @param conn the netconn to free
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   792   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   793  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   794  netconn_free(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   795  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   796    LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   797  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   798  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   799    /* in fullduplex, netconn is drained here */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   800    netconn_drain(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   801  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   802  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   803    LWIP_ASSERT("recvmbox must be deallocated before calling this function",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   804                !sys_mbox_valid(&conn->recvmbox));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   805  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   806    LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   807                !sys_mbox_valid(&conn->acceptmbox));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   808  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   809  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   810  #if !LWIP_NETCONN_SEM_PER_THREAD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   811    sys_sem_free(&conn->op_completed);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   812    sys_sem_set_invalid(&conn->op_completed);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   813  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   814  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   815    memp_free(MEMP_NETCONN, conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   816  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   817  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   818  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   819   * Delete rcvmbox and acceptmbox of a netconn and free the left-over data in
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   820   * these mboxes
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   821   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   822   * @param conn the netconn to free
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   823   * @bytes_drained bytes drained from recvmbox
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   824   * @accepts_drained pending connections drained from acceptmbox
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   825   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   826  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   827  netconn_drain(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   828  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   829    void *mem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   830  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   831    /* This runs when mbox and netconn are marked as closed,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   832       so we don't need to lock against rx packets */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   833  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   834    LWIP_ASSERT("netconn marked closed", conn->flags & NETCONN_FLAG_MBOXINVALID);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   835  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   836  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   837    /* Delete and drain the recvmbox. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   838    if (sys_mbox_valid(&conn->recvmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   839      while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   840  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   841        if (!lwip_netconn_is_deallocated_msg(mem))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   842  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   843        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   844  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   845          if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   846            err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   847            if (!lwip_netconn_is_err_msg(mem, &err)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   848              pbuf_free((struct pbuf *)mem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   849            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   850          } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   851  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   852          {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   853            netbuf_delete((struct netbuf *)mem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   854          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   855        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   856      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   857      sys_mbox_free(&conn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   858      sys_mbox_set_invalid(&conn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   859    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   860  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   861    /* Delete and drain the acceptmbox. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   862  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   863    if (sys_mbox_valid(&conn->acceptmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   864      while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   865  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   866        if (!lwip_netconn_is_deallocated_msg(mem))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   867  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   868        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   869          err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   870          if (!lwip_netconn_is_err_msg(mem, &err)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   871            struct netconn *newconn = (struct netconn *)mem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   872            /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   873            /* pcb might be set to NULL already by err_tcp() */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   874            /* drain recvmbox */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   875            netconn_drain(newconn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   876            if (newconn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   877              tcp_abort(newconn->pcb.tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   878              newconn->pcb.tcp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   879            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   880            netconn_free(newconn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   881          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   882        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   883      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   884      sys_mbox_free(&conn->acceptmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   885      sys_mbox_set_invalid(&conn->acceptmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   886    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   887  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   888  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   889  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   890  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   891  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   892  netconn_mark_mbox_invalid(struct netconn *conn)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   893  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   894    int i, num_waiting;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   895    void *msg = LWIP_CONST_CAST(void *, &netconn_deleted);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   896  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   897    /* Prevent new calls/threads from reading from the mbox */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   898    conn->flags |= NETCONN_FLAG_MBOXINVALID;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   899  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   900    SYS_ARCH_LOCKED(num_waiting = conn->mbox_threads_waiting);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   901    for (i = 0; i < num_waiting; i++) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   902      if (sys_mbox_valid_val(conn->recvmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   903        sys_mbox_trypost(&conn->recvmbox, msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   904      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   905        sys_mbox_trypost(&conn->acceptmbox, msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   906      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   907    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   908  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   909  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   910  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   911  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   912  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   913   * Internal helper function to close a TCP netconn: since this sometimes
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   914   * doesn't work at the first attempt, this function is called from multiple
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   915   * places.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   916   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   917   * @param conn the TCP netconn to close
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   918   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   919  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   920  lwip_netconn_do_close_internal(struct netconn *conn  WRITE_DELAYED_PARAM)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   921  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   922    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   923    u8_t shut, shut_rx, shut_tx, shut_close;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   924    u8_t close_finished = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   925    struct tcp_pcb *tpcb;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   926  #if LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   927    u8_t linger_wait_required = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   928  #endif /* LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   929  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   930    LWIP_ASSERT("invalid conn", (conn != NULL));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   931    LWIP_ASSERT("this is for tcp netconns only", (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   932    LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   933    LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   934    LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   935  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   936    tpcb = conn->pcb.tcp;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   937    shut = conn->current_msg->msg.sd.shut;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   938    shut_rx = shut & NETCONN_SHUT_RD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   939    shut_tx = shut & NETCONN_SHUT_WR;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   940    /* shutting down both ends is the same as closing
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   941       (also if RD or WR side was shut down before already) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   942    if (shut == NETCONN_SHUT_RDWR) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   943      shut_close = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   944    } else if (shut_rx &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   945               ((tpcb->state == FIN_WAIT_1) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   946                (tpcb->state == FIN_WAIT_2) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   947                (tpcb->state == CLOSING))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   948      shut_close = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   949    } else if (shut_tx && ((tpcb->flags & TF_RXCLOSED) != 0)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   950      shut_close = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   951    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   952      shut_close = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   953    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   954  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   955    /* Set back some callback pointers */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   956    if (shut_close) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   957      tcp_arg(tpcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   958    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   959    if (tpcb->state == LISTEN) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   960      tcp_accept(tpcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   961    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   962      /* some callbacks have to be reset if tcp_close is not successful */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   963      if (shut_rx) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   964        tcp_recv(tpcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   965        tcp_accept(tpcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   966      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   967      if (shut_tx) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   968        tcp_sent(tpcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   969      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   970      if (shut_close) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   971        tcp_poll(tpcb, NULL, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   972        tcp_err(tpcb, NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   973      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   974    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   975    /* Try to close the connection */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   976    if (shut_close) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   977  #if LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   978      /* check linger possibilites before calling tcp_close */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   979      err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   980      /* linger enabled/required at all? (i.e. is there untransmitted data left?) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   981      if ((conn->linger >= 0) && (conn->pcb.tcp->unsent || conn->pcb.tcp->unacked)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   982        if ((conn->linger == 0)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   983          /* data left but linger prevents waiting */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   984          tcp_abort(tpcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   985          tpcb = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   986        } else if (conn->linger > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   987          /* data left and linger says we should wait */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   988          if (netconn_is_nonblocking(conn)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   989            /* data left on a nonblocking netconn -> cannot linger */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   990            err = ERR_WOULDBLOCK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   991          } else if ((s32_t)(sys_now() - conn->current_msg->msg.sd.time_started) >=
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   992                     (conn->linger * 1000)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   993            /* data left but linger timeout has expired (this happens on further
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   994               calls to this function through poll_tcp */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   995            tcp_abort(tpcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   996            tpcb = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   997          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   998            /* data left -> need to wait for ACK after successful close */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	   999            linger_wait_required = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1000          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1001        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1002      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1003      if ((err == ERR_OK) && (tpcb != NULL))
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1004  #endif /* LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1005      {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1006        err = tcp_close(tpcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1007      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1008    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1009      err = tcp_shutdown(tpcb, shut_rx, shut_tx);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1010    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1011    if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1012      close_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1013  #if LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1014      if (linger_wait_required) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1015        /* wait for ACK of all unsent/unacked data by just getting called again */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1016        close_finished = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1017        err = ERR_INPROGRESS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1018      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1019  #endif /* LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1020    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1021      if (err == ERR_MEM) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1022        /* Closing failed because of memory shortage, try again later. Even for
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1023           nonblocking netconns, we have to wait since no standard socket application
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1024           is prepared for close failing because of resource shortage.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1025           Check the timeout: this is kind of an lwip addition to the standard sockets:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1026           we wait for some time when failing to allocate a segment for the FIN */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1027  #if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1028        s32_t close_timeout = LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1029  #if LWIP_SO_SNDTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1030        if (conn->send_timeout > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1031          close_timeout = conn->send_timeout;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1032        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1033  #endif /* LWIP_SO_SNDTIMEO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1034  #if LWIP_SO_LINGER
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1035        if (conn->linger >= 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1036          /* use linger timeout (seconds) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1037          close_timeout = conn->linger * 1000U;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1038        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1039  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1040        if ((s32_t)(sys_now() - conn->current_msg->msg.sd.time_started) >= close_timeout) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1041  #else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1042        if (conn->current_msg->msg.sd.polls_left == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1043  #endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1044          close_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1045          if (shut_close) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1046            /* in this case, we want to RST the connection */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1047            tcp_abort(tpcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1048            err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1049          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1050        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1051      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1052        /* Closing failed for a non-memory error: give up */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1053        close_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1054      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1055    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1056    if (close_finished) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1057      /* Closing done (succeeded, non-memory error, nonblocking error or timeout) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1058      sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1059      conn->current_msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1060      conn->current_msg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1061      conn->state = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1062      if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1063        if (shut_close) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1064          /* Set back some callback pointers as conn is going away */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1065          conn->pcb.tcp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1066          /* Trigger select() in socket layer. Make sure everybody notices activity
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1067           on the connection, error first! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1068          API_EVENT(conn, NETCONN_EVT_ERROR, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1069        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1070        if (shut_rx) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1071          API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1072        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1073        if (shut_tx) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1074          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1075        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1076      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1077  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1078      if (delayed)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1079  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1080      {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1081        /* wake up the application task */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1082        sys_sem_signal(op_completed_sem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1083      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1084      return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1085    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1086    if (!close_finished) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1087      /* Closing failed and we want to wait: restore some of the callbacks */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1088      /* Closing of listen pcb will never fail! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1089      LWIP_ASSERT("Closing a listen pcb may not fail!", (tpcb->state != LISTEN));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1090      if (shut_tx) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1091        tcp_sent(tpcb, sent_tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1092      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1093      /* when waiting for close, set up poll interval to 500ms */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1094      tcp_poll(tpcb, poll_tcp, 1);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1095      tcp_err(tpcb, err_tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1096      tcp_arg(tpcb, conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1097      /* don't restore recv callback: we don't want to receive any more data */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1098    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1099    /* If closing didn't succeed, we get called again either
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1100       from poll_tcp or from sent_tcp */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1101    LWIP_ASSERT("err != ERR_OK", err != ERR_OK);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1102    return err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1103  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1104  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1105  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1106  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1107   * Delete the pcb inside a netconn.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1108   * Called from netconn_delete.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1109   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1110   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1111   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1112  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1113  lwip_netconn_do_delconn(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1114  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1115    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1116  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1117    enum netconn_state state = msg->conn->state;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1118    LWIP_ASSERT("netconn state error", /* this only happens for TCP netconns */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1119                (state == NETCONN_NONE) || (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1120  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1121    /* In full duplex mode, blocking write/connect is aborted with ERR_CLSD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1122    if (state != NETCONN_NONE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1123      if ((state == NETCONN_WRITE) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1124          ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1125        /* close requested, abort running write/connect */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1126        sys_sem_t *op_completed_sem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1127        LWIP_ASSERT("msg->conn->current_msg != NULL", msg->conn->current_msg != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1128        op_completed_sem = LWIP_API_MSG_SEM(msg->conn->current_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1129        msg->conn->current_msg->err = ERR_CLSD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1130        msg->conn->current_msg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1131        msg->conn->state = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1132        sys_sem_signal(op_completed_sem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1133      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1134    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1135  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1136    if (((state != NETCONN_NONE) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1137         (state != NETCONN_LISTEN) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1138         (state != NETCONN_CONNECT)) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1139        ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1140      /* This means either a blocking write or blocking connect is running
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1141         (nonblocking write returns and sets state to NONE) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1142      msg->err = ERR_INPROGRESS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1143    } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1144  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1145    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1146      LWIP_ASSERT("blocking connect in progress",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1147                  (state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1148      msg->err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1149  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1150      /* Mark mboxes invalid */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1151      netconn_mark_mbox_invalid(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1152  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1153      netconn_drain(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1154  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1155  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1156      if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1157  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1158        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1159  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1160          case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1161            raw_remove(msg->conn->pcb.raw);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1162            break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1163  #endif /* LWIP_RAW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1164  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1165          case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1166            msg->conn->pcb.udp->recv_arg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1167            udp_remove(msg->conn->pcb.udp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1168            break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1169  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1170  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1171          case NETCONN_TCP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1172            LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1173            msg->conn->state = NETCONN_CLOSE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1174            msg->msg.sd.shut = NETCONN_SHUT_RDWR;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1175            msg->conn->current_msg = msg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1176  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1177            if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1178              LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1179              UNLOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1180              sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1181              LOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1182              LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1183            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1184  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1185            lwip_netconn_do_close_internal(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1186  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1187            /* API_EVENT is called inside lwip_netconn_do_close_internal, before releasing
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1188               the application thread, so we can return at this point! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1189            return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1190  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1191          default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1192            break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1193        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1194        msg->conn->pcb.tcp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1195      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1196      /* tcp netconns don't come here! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1197  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1198      /* @todo: this lets select make the socket readable and writable,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1199         which is wrong! errfd instead? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1200      API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1201      API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1202    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1203    if (sys_sem_valid(LWIP_API_MSG_SEM(msg))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1204      TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1205    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1206  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1207  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1208  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1209   * Bind a pcb contained in a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1210   * Called from netconn_bind.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1211   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1212   * @param m the api_msg pointing to the connection and containing
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1213   *          the IP address and port to bind to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1214   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1215  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1216  lwip_netconn_do_bind(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1217  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1218    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1219    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1220  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1221    if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1222      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1223  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1224        case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1225          err = raw_bind(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1226          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1227  #endif /* LWIP_RAW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1228  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1229        case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1230          err = udp_bind(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1231          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1232  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1233  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1234        case NETCONN_TCP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1235          err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1236          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1237  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1238        default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1239          err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1240          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1241      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1242    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1243      err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1244    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1245    msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1246    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1247  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1248  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1249   * Bind a pcb contained in a netconn to an interface
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1250   * Called from netconn_bind_if.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1251   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1252   * @param m the api_msg pointing to the connection and containing
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1253   *          the IP address and port to bind to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1254   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1255  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1256  lwip_netconn_do_bind_if(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1257  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1258    struct netif *netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1259    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1260    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1261  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1262    netif = netif_get_by_index(msg->msg.bc.if_idx);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1263  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1264    if ((netif != NULL) && (msg->conn->pcb.tcp != NULL)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1265      err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1266      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1267  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1268        case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1269          raw_bind_netif(msg->conn->pcb.raw, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1270          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1271  #endif /* LWIP_RAW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1272  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1273        case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1274          udp_bind_netif(msg->conn->pcb.udp, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1275          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1276  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1277  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1278        case NETCONN_TCP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1279          tcp_bind_netif(msg->conn->pcb.tcp, netif);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1280          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1281  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1282        default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1283          err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1284          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1285      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1286    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1287      err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1288    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1289    msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1290    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1291  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1292  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1293  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1294  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1295   * TCP callback function if a connection (opened by tcp_connect/lwip_netconn_do_connect) has
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1296   * been established (or reset by the remote host).
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1297   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1298   * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1299   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1300  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1301  lwip_netconn_do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1302  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1303    struct netconn *conn;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1304    int was_blocking;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1305    sys_sem_t *op_completed_sem = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1306  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1307    LWIP_UNUSED_ARG(pcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1308  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1309    conn = (struct netconn *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1310  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1311    if (conn == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1312      return ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1313    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1314  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1315    LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1316    LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1317                (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1318  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1319    if (conn->current_msg != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1320      conn->current_msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1321      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1322    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1323    if ((NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) && (err == ERR_OK)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1324      setup_tcp(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1325    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1326    was_blocking = !IN_NONBLOCKING_CONNECT(conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1327    SET_NONBLOCKING_CONNECT(conn, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1328    LWIP_ASSERT("blocking connect state error",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1329                (was_blocking && op_completed_sem != NULL) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1330                (!was_blocking && op_completed_sem == NULL));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1331    conn->current_msg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1332    conn->state = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1333    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1334  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1335    if (was_blocking) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1336      sys_sem_signal(op_completed_sem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1337    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1338    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1339  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1340  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1341  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1342  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1343   * Connect a pcb contained inside a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1344   * Called from netconn_connect.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1345   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1346   * @param m the api_msg pointing to the connection and containing
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1347   *          the IP address and port to connect to
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1348   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1349  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1350  lwip_netconn_do_connect(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1351  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1352    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1353    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1354  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1355    if (msg->conn->pcb.tcp == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1356      /* This may happen when calling netconn_connect() a second time */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1357      err = ERR_CLSD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1358    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1359      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1360  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1361        case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1362          err = raw_connect(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1363          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1364  #endif /* LWIP_RAW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1365  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1366        case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1367          err = udp_connect(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1368          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1369  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1370  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1371        case NETCONN_TCP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1372          /* Prevent connect while doing any other action. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1373          if (msg->conn->state == NETCONN_CONNECT) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1374            err = ERR_ALREADY;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1375          } else if (msg->conn->state != NETCONN_NONE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1376            err = ERR_ISCONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1377          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1378            setup_tcp(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1379            err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1380                              msg->msg.bc.port, lwip_netconn_do_connected);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1381            if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1382              u8_t non_blocking = netconn_is_nonblocking(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1383              msg->conn->state = NETCONN_CONNECT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1384              SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1385              if (non_blocking) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1386                err = ERR_INPROGRESS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1387              } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1388                msg->conn->current_msg = msg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1389                /* sys_sem_signal() is called from lwip_netconn_do_connected (or err_tcp()),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1390                   when the connection is established! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1391  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1392                LWIP_ASSERT("state!", msg->conn->state == NETCONN_CONNECT);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1393                UNLOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1394                sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1395                LOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1396                LWIP_ASSERT("state!", msg->conn->state != NETCONN_CONNECT);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1397  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1398                return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1399              }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1400            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1401          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1402          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1403  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1404        default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1405          LWIP_ERROR("Invalid netconn type", 0, do {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1406            err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1407          } while (0));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1408          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1409      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1410    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1411    msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1412    /* For all other protocols, netconn_connect() calls netconn_apimsg(),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1413       so use TCPIP_APIMSG_ACK() here. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1414    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1415  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1416  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1417  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1418   * Disconnect a pcb contained inside a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1419   * Only used for UDP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1420   * Called from netconn_disconnect.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1421   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1422   * @param m the api_msg pointing to the connection to disconnect
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1423   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1424  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1425  lwip_netconn_do_disconnect(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1426  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1427    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1428  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1429  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1430    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1431      udp_disconnect(msg->conn->pcb.udp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1432      msg->err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1433    } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1434  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1435    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1436      msg->err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1437    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1438    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1439  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1440  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1441  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1442  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1443   * Set a TCP pcb contained in a netconn into listen mode
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1444   * Called from netconn_listen.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1445   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1446   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1447   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1448  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1449  lwip_netconn_do_listen(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1450  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1451    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1452    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1453  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1454    if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1455      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1456        if (msg->conn->state == NETCONN_NONE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1457          struct tcp_pcb *lpcb;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1458          if (msg->conn->pcb.tcp->state != CLOSED) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1459            /* connection is not closed, cannot listen */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1460            err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1461          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1462            u8_t backlog;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1463  #if TCP_LISTEN_BACKLOG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1464            backlog = msg->msg.lb.backlog;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1465  #else  /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1466            backlog = TCP_DEFAULT_LISTEN_BACKLOG;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1467  #endif /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1468  #if LWIP_IPV4 && LWIP_IPV6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1469            /* "Socket API like" dual-stack support: If IP to listen to is IP6_ADDR_ANY,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1470              * and NETCONN_FLAG_IPV6_V6ONLY is NOT set, use IP_ANY_TYPE to listen
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1471              */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1472            if (ip_addr_cmp(&msg->conn->pcb.ip->local_ip, IP6_ADDR_ANY) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1473                (netconn_get_ipv6only(msg->conn) == 0)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1474              /* change PCB type to IPADDR_TYPE_ANY */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1475              IP_SET_TYPE_VAL(msg->conn->pcb.tcp->local_ip,  IPADDR_TYPE_ANY);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1476              IP_SET_TYPE_VAL(msg->conn->pcb.tcp->remote_ip, IPADDR_TYPE_ANY);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1477            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1478  #endif /* LWIP_IPV4 && LWIP_IPV6 */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1479  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1480            lpcb = tcp_listen_with_backlog_and_err(msg->conn->pcb.tcp, backlog, &err);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1481  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1482            if (lpcb == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1483              /* in this case, the old pcb is still allocated */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1484            } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1485              /* delete the recvmbox and allocate the acceptmbox */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1486              if (sys_mbox_valid(&msg->conn->recvmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1487                /** @todo: should we drain the recvmbox here? */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1488                sys_mbox_free(&msg->conn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1489                sys_mbox_set_invalid(&msg->conn->recvmbox);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1490              }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1491              err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1492              if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1493                err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1494              }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1495              if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1496                msg->conn->state = NETCONN_LISTEN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1497                msg->conn->pcb.tcp = lpcb;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1498                tcp_arg(msg->conn->pcb.tcp, msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1499                tcp_accept(msg->conn->pcb.tcp, accept_function);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1500              } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1501                /* since the old pcb is already deallocated, free lpcb now */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1502                tcp_close(lpcb);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1503                msg->conn->pcb.tcp = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1504              }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1505            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1506          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1507        } else if (msg->conn->state == NETCONN_LISTEN) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1508          /* already listening, allow updating of the backlog */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1509          err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1510          tcp_backlog_set(msg->conn->pcb.tcp, msg->msg.lb.backlog);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1511        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1512          err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1513        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1514      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1515        err = ERR_ARG;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1516      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1517    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1518      err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1519    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1520    msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1521    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1522  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1523  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1524  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1525  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1526   * Send some data on a RAW or UDP pcb contained in a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1527   * Called from netconn_send
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1528   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1529   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1530   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1531  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1532  lwip_netconn_do_send(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1533  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1534    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1535  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1536    err_t err = netconn_err(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1537    if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1538      if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1539        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1540  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1541          case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1542            if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1543              err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1544            } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1545              err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1546            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1547            break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1548  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1549  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1550          case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1551  #if LWIP_CHECKSUM_ON_COPY
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1552            if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1553              err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1554                                    msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1555            } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1556              err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1557                                      &msg->msg.b->addr, msg->msg.b->port,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1558                                      msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1559            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1560  #else /* LWIP_CHECKSUM_ON_COPY */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1561            if (ip_addr_isany_val(msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1562              err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1563            } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1564              err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1565            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1566  #endif /* LWIP_CHECKSUM_ON_COPY */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1567            break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1568  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1569          default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1570            err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1571            break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1572        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1573      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1574        err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1575      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1576    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1577    msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1578    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1579  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1580  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1581  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1582  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1583   * Indicate data has been received from a TCP pcb contained in a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1584   * Called from netconn_recv
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1585   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1586   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1587   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1588  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1589  lwip_netconn_do_recv(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1590  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1591    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1592  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1593    msg->err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1594    if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1595      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1596        size_t remaining = msg->msg.r.len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1597        do {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1598          u16_t recved = (u16_t)((remaining > 0xffff) ? 0xffff : remaining);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1599          tcp_recved(msg->conn->pcb.tcp, recved);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1600          remaining -= recved;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1601        } while (remaining != 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1602      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1603    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1604    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1605  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1606  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1607  #if TCP_LISTEN_BACKLOG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1608  /** Indicate that a TCP pcb has been accepted
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1609   * Called from netconn_accept
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1610   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1611   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1612   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1613  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1614  lwip_netconn_do_accepted(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1615  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1616    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1617  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1618    msg->err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1619    if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1620      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1621        tcp_backlog_accepted(msg->conn->pcb.tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1622      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1623    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1624    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1625  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1626  #endif /* TCP_LISTEN_BACKLOG */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1627  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1628  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1629   * See if more data needs to be written from a previous call to netconn_write.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1630   * Called initially from lwip_netconn_do_write. If the first call can't send all data
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1631   * (because of low memory or empty send-buffer), this function is called again
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1632   * from sent_tcp() or poll_tcp() to send more data. If all data is sent, the
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1633   * blocking application thread (waiting in netconn_write) is released.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1634   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1635   * @param conn netconn (that is currently in state NETCONN_WRITE) to process
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1636   * @return ERR_OK
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1637   *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1638   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1639  static err_t
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1640  lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1641  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1642    err_t err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1643    const void *dataptr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1644    u16_t len, available;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1645    u8_t write_finished = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1646    size_t diff;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1647    u8_t dontblock;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1648    u8_t apiflags;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1649    u8_t write_more;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1650  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1651    LWIP_ASSERT("conn != NULL", conn != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1652    LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1653    LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1654    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1655    LWIP_ASSERT("conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1656                conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1657    LWIP_ASSERT("conn->current_msg->msg.w.vector_cnt > 0", conn->current_msg->msg.w.vector_cnt > 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1658  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1659    apiflags = conn->current_msg->msg.w.apiflags;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1660    dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1661  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1662  #if LWIP_SO_SNDTIMEO
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1663    if ((conn->send_timeout != 0) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1664        ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1665      write_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1666      if (conn->current_msg->msg.w.offset == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1667        /* nothing has been written */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1668        err = ERR_WOULDBLOCK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1669      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1670        /* partial write */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1671        err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1672      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1673    } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1674  #endif /* LWIP_SO_SNDTIMEO */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1675    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1676      do {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1677        dataptr = (const u8_t *)conn->current_msg->msg.w.vector->ptr + conn->current_msg->msg.w.vector_off;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1678        diff = conn->current_msg->msg.w.vector->len - conn->current_msg->msg.w.vector_off;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1679        if (diff > 0xffffUL) { /* max_u16_t */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1680          len = 0xffff;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1681          apiflags |= TCP_WRITE_FLAG_MORE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1682        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1683          len = (u16_t)diff;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1684        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1685        available = tcp_sndbuf(conn->pcb.tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1686        if (available < len) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1687          /* don't try to write more than sendbuf */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1688          len = available;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1689          if (dontblock) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1690            if (!len) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1691              /* set error according to partial write or not */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1692              err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1693              goto err_mem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1694            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1695          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1696            apiflags |= TCP_WRITE_FLAG_MORE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1697          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1698        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1699        LWIP_ASSERT("lwip_netconn_do_writemore: invalid length!",
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1700                    ((conn->current_msg->msg.w.vector_off + len) <= conn->current_msg->msg.w.vector->len));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1701        /* we should loop around for more sending in the following cases:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1702             1) We couldn't finish the current vector because of 16-bit size limitations.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1703                tcp_write() and tcp_sndbuf() both are limited to 16-bit sizes
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1704             2) We are sending the remainder of the current vector and have more */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1705        if ((len == 0xffff && diff > 0xffffUL) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1706            (len == (u16_t)diff && conn->current_msg->msg.w.vector_cnt > 1)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1707          write_more = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1708          apiflags |= TCP_WRITE_FLAG_MORE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1709        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1710          write_more = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1711        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1712        err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1713        if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1714          conn->current_msg->msg.w.offset += len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1715          conn->current_msg->msg.w.vector_off += len;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1716          /* check if current vector is finished */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1717          if (conn->current_msg->msg.w.vector_off == conn->current_msg->msg.w.vector->len) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1718            conn->current_msg->msg.w.vector_cnt--;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1719            /* if we have additional vectors, move on to them */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1720            if (conn->current_msg->msg.w.vector_cnt > 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1721              conn->current_msg->msg.w.vector++;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1722              conn->current_msg->msg.w.vector_off = 0;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1723            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1724          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1725        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1726      } while (write_more && err == ERR_OK);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1727      /* if OK or memory error, check available space */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1728      if ((err == ERR_OK) || (err == ERR_MEM)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1729  err_mem:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1730        if (dontblock && (conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1731          /* non-blocking write did not write everything: mark the pcb non-writable
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1732             and let poll_tcp check writable space to mark the pcb writable again */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1733          API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1734          conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1735        } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1736                   (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1737          /* The queued byte- or pbuf-count exceeds the configured low-water limit,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1738             let select mark this pcb as non-writable. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1739          API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1740        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1741      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1742  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1743      if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1744        err_t out_err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1745        if ((conn->current_msg->msg.w.offset == conn->current_msg->msg.w.len) || dontblock) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1746          /* return sent length (caller reads length from msg.w.offset) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1747          write_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1748        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1749        out_err = tcp_output(conn->pcb.tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1750        if (out_err == ERR_RTE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1751          /* If tcp_output fails because no route is found,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1752             don't try writing any more but return the error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1753             to the application thread. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1754          err = out_err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1755          write_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1756        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1757      } else if (err == ERR_MEM) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1758        /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1759           For blocking sockets, we do NOT return to the application
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1760           thread, since ERR_MEM is only a temporary error! Non-blocking
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1761           will remain non-writable until sent_tcp/poll_tcp is called */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1762  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1763        /* tcp_write returned ERR_MEM, try tcp_output anyway */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1764        err_t out_err = tcp_output(conn->pcb.tcp);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1765        if (out_err == ERR_RTE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1766          /* If tcp_output fails because no route is found,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1767             don't try writing any more but return the error
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1768             to the application thread. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1769          err = out_err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1770          write_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1771        } else if (dontblock) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1772          /* non-blocking write is done on ERR_MEM, set error according
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1773             to partial write or not */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1774          err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1775          write_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1776        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1777      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1778        /* On errors != ERR_MEM, we don't try writing any more but return
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1779           the error to the application thread. */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1780        write_finished = 1;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1781      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1782    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1783    if (write_finished) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1784      /* everything was written: set back connection state
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1785         and back to application task */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1786      sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1787      conn->current_msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1788      conn->current_msg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1789      conn->state = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1790  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1791      if (delayed)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1792  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1793      {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1794        sys_sem_signal(op_completed_sem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1795      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1796    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1797  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1798    else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1799      return ERR_MEM;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1800    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1801  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1802    return ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1803  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1804  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1805  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1806  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1807   * Send some data on a TCP pcb contained in a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1808   * Called from netconn_write
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1809   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1810   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1811   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1812  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1813  lwip_netconn_do_write(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1814  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1815    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1816  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1817    err_t err = netconn_err(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1818    if (err == ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1819      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1820  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1821        if (msg->conn->state != NETCONN_NONE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1822          /* netconn is connecting, closing or in blocking write */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1823          err = ERR_INPROGRESS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1824        } else if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1825          msg->conn->state = NETCONN_WRITE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1826          /* set all the variables used by lwip_netconn_do_writemore */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1827          LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1828          LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1829          msg->conn->current_msg = msg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1830  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1831          if (lwip_netconn_do_writemore(msg->conn, 0) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1832            LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1833            UNLOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1834            sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1835            LOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1836            LWIP_ASSERT("state!", msg->conn->state != NETCONN_WRITE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1837          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1838  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1839          lwip_netconn_do_writemore(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1840  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1841          /* for both cases: if lwip_netconn_do_writemore was called, don't ACK the APIMSG
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1842             since lwip_netconn_do_writemore ACKs it! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1843          return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1844        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1845          err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1846        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1847  #else /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1848        err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1849  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1850  #if (LWIP_UDP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1851      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1852        err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1853  #endif /* (LWIP_UDP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1854      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1855    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1856    msg->err = err;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1857    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1858  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1859  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1860  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1861   * Return a connection's local or remote address
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1862   * Called from netconn_getaddr
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1863   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1864   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1865   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1866  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1867  lwip_netconn_do_getaddr(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1868  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1869    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1870  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1871    if (msg->conn->pcb.ip != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1872      if (msg->msg.ad.local) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1873        ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1874                     msg->conn->pcb.ip->local_ip);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1875      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1876        ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1877                     msg->conn->pcb.ip->remote_ip);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1878      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1879  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1880      msg->err = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1881      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1882  #if LWIP_RAW
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1883        case NETCONN_RAW:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1884          if (msg->msg.ad.local) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1885            API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1886          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1887            /* return an error as connecting is only a helper for upper layers */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1888            msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1889          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1890          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1891  #endif /* LWIP_RAW */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1892  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1893        case NETCONN_UDP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1894          if (msg->msg.ad.local) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1895            API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1896          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1897            if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1898              msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1899            } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1900              API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1901            }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1902          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1903          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1904  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1905  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1906        case NETCONN_TCP:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1907          if ((msg->msg.ad.local == 0) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1908              ((msg->conn->pcb.tcp->state == CLOSED) || (msg->conn->pcb.tcp->state == LISTEN))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1909            /* pcb is not connected and remote name is requested */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1910            msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1911          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1912            API_EXPR_DEREF(msg->msg.ad.port) = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1913          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1914          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1915  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1916        default:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1917          LWIP_ASSERT("invalid netconn_type", 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1918          break;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1919      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1920    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1921      msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1922    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1923    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1924  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1925  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1926  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1927   * Close or half-shutdown a TCP pcb contained in a netconn
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1928   * Called from netconn_close
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1929   * In contrast to closing sockets, the netconn is not deallocated.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1930   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1931   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1932   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1933  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1934  lwip_netconn_do_close(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1935  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1936    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1937  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1938  #if LWIP_TCP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1939    enum netconn_state state = msg->conn->state;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1940    /* First check if this is a TCP netconn and if it is in a correct state
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1941        (LISTEN doesn't support half shutdown) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1942    if ((msg->conn->pcb.tcp != NULL) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1943        (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1944        ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1945      /* Check if we are in a connected state */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1946      if (state == NETCONN_CONNECT) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1947        /* TCP connect in progress: cannot shutdown */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1948        msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1949      } else if (state == NETCONN_WRITE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1950  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1951        if (msg->msg.sd.shut & NETCONN_SHUT_WR) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1952          /* close requested, abort running write */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1953          sys_sem_t *write_completed_sem;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1954          LWIP_ASSERT("msg->conn->current_msg != NULL", msg->conn->current_msg != NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1955          write_completed_sem = LWIP_API_MSG_SEM(msg->conn->current_msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1956          msg->conn->current_msg->err = ERR_CLSD;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1957          msg->conn->current_msg = NULL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1958          msg->conn->state = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1959          state = NETCONN_NONE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1960          sys_sem_signal(write_completed_sem);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1961        } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1962          LWIP_ASSERT("msg->msg.sd.shut == NETCONN_SHUT_RD", msg->msg.sd.shut == NETCONN_SHUT_RD);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1963          /* In this case, let the write continue and do not interfere with
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1964             conn->current_msg or conn->state! */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1965          msg->err = tcp_shutdown(msg->conn->pcb.tcp, 1, 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1966        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1967      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1968      if (state == NETCONN_NONE) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1969  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1970        msg->err = ERR_INPROGRESS;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1971      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1972  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1973        if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1974  #if LWIP_NETCONN_FULLDUPLEX
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1975          /* Mark mboxes invalid */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1976          netconn_mark_mbox_invalid(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1977  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1978          netconn_drain(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1979  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1980        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1981        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1982        msg->conn->state = NETCONN_CLOSE;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1983        msg->conn->current_msg = msg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1984  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1985        if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1986          LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1987          UNLOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1988          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1989          LOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1990          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1991        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1992  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1993        lwip_netconn_do_close_internal(msg->conn);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1994  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1995        /* for tcp netconns, lwip_netconn_do_close_internal ACKs the message */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1996        return;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1997      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1998    } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  1999  #endif /* LWIP_TCP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2000    {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2001      msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2002    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2003    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2004  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2005  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2006  #if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2007  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2008   * Join multicast groups for UDP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2009   * Called from netconn_join_leave_group
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2010   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2011   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2012   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2013  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2014  lwip_netconn_do_join_leave_group(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2015  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2016    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2017  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2018    msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2019    if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2020      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2021  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2022  #if LWIP_IPV6 && LWIP_IPV6_MLD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2023        if (NETCONNTYPE_ISIPV6(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2024          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2025            msg->err = mld6_joingroup(ip_2_ip6(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2026                                      ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2027          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2028            msg->err = mld6_leavegroup(ip_2_ip6(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2029                                       ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2030          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2031        } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2032  #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2033        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2034  #if LWIP_IGMP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2035          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2036            msg->err = igmp_joingroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2037                                      ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2038          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2039            msg->err = igmp_leavegroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2040                                       ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2041          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2042  #endif /* LWIP_IGMP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2043        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2044  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2045  #if (LWIP_TCP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2046      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2047        msg->err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2048  #endif /* (LWIP_TCP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2049      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2050    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2051    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2052  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2053  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2054   * Join multicast groups for UDP netconns.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2055   * Called from netconn_join_leave_group_netif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2056   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2057   * @param m the api_msg pointing to the connection
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2058   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2059  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2060  lwip_netconn_do_join_leave_group_netif(void *m)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2061  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2062    struct api_msg *msg = (struct api_msg *)m;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2063    struct netif *netif;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2064  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2065    netif = netif_get_by_index(msg->msg.jl.if_idx);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2066    if (netif == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2067      msg->err = ERR_IF;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2068      goto done;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2069    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2070  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2071    msg->err = ERR_CONN;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2072    if (msg->conn->pcb.tcp != NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2073      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2074  #if LWIP_UDP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2075  #if LWIP_IPV6 && LWIP_IPV6_MLD
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2076        if (NETCONNTYPE_ISIPV6(msg->conn->type)) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2077          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2078            msg->err = mld6_joingroup_netif(netif,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2079                                            ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2080          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2081            msg->err = mld6_leavegroup_netif(netif,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2082                                             ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2083          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2084        } else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2085  #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2086        {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2087  #if LWIP_IGMP
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2088          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2089            msg->err = igmp_joingroup_netif(netif,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2090                                            ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2091          } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2092            msg->err = igmp_leavegroup_netif(netif,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2093                                             ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2094          }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2095  #endif /* LWIP_IGMP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2096        }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2097  #endif /* LWIP_UDP */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2098  #if (LWIP_TCP || LWIP_RAW)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2099      } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2100        msg->err = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2101  #endif /* (LWIP_TCP || LWIP_RAW) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2102      }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2103    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2104  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2105  done:
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2106    TCPIP_APIMSG_ACK(msg);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2107  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2108  #endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2109  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2110  #if LWIP_DNS
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2111  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2112   * Callback function that is called when DNS name is resolved
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2113   * (or on timeout). A waiting application thread is waked up by
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2114   * signaling the semaphore.
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2115   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2116  static void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2117  lwip_netconn_do_dns_found(const char *name, const ip_addr_t *ipaddr, void *arg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2118  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2119    struct dns_api_msg *msg = (struct dns_api_msg *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2120  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2121    /* we trust the internal implementation to be correct :-) */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2122    LWIP_UNUSED_ARG(name);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2123  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2124    if (ipaddr == NULL) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2125      /* timeout or memory error */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2126      API_EXPR_DEREF(msg->err) = ERR_VAL;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2127    } else {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2128      /* address was resolved */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2129      API_EXPR_DEREF(msg->err) = ERR_OK;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2130      API_EXPR_DEREF(msg->addr) = *ipaddr;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2131    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2132    /* wake up the application task waiting in netconn_gethostbyname */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2133    sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2134  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2135  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2136  /**
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2137   * Execute a DNS query
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2138   * Called from netconn_gethostbyname
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2139   *
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2140   * @param arg the dns_api_msg pointing to the query
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2141   */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2142  void
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2143  lwip_netconn_do_gethostbyname(void *arg)
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2144  {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2145    struct dns_api_msg *msg = (struct dns_api_msg *)arg;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2146    u8_t addrtype =
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2147  #if LWIP_IPV4 && LWIP_IPV6
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2148      msg->dns_addrtype;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2149  #else
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2150      LWIP_DNS_ADDRTYPE_DEFAULT;
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2151  #endif
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2152  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2153    API_EXPR_DEREF(msg->err) = dns_gethostbyname_addrtype(msg->name,
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2154                               API_EXPR_REF(msg->addr), lwip_netconn_do_dns_found, msg, addrtype);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2155  #if LWIP_TCPIP_CORE_LOCKING
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2156    /* For core locking, only block if we need to wait for answer/timeout */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2157    if (API_EXPR_DEREF(msg->err) == ERR_INPROGRESS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2158      UNLOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2159      sys_sem_wait(API_EXPR_REF_SEM(msg->sem));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2160      LOCK_TCPIP_CORE();
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2161      LWIP_ASSERT("do_gethostbyname still in progress!!", API_EXPR_DEREF(msg->err) != ERR_INPROGRESS);
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2162    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2163  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2164    if (API_EXPR_DEREF(msg->err) != ERR_INPROGRESS) {
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2165      /* on error or immediate success, wake up the application
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2166       * task waiting in netconn_gethostbyname */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2167      sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2168    }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2169  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2170  }
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2171  #endif /* LWIP_DNS */
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2172  
; ..\0_Src\0_AppSw\Ethernet\lwip\src\api\api_msg.c	  2173  #endif /* LWIP_NETCONN */

	; Module end
