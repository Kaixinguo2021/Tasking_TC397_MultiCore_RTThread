	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.3r1 Build 19041558 SN 09003382"
	.compiler_invocation	"ctc --dep-file=0_Src\\0_AppSw\\Tricore\\rt-thread\\src\\.slab.o.d --fp-model=c,l,f,z,n,r,S,T -D__CPU__=tc39x -D__CPU_TC39X__ --core=tc1.6.2 --iso=99 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread\\libcpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\UART -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread\\include -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread\\include\\libc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread\\libcpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread\\src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Asc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6\\Icu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmBc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6\\TimerWithTrigger -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6\\TPwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Convctrl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dma\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dma\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dts\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dts\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ebu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSpansion -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ebu\\BFlashSt -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ebu\\Dram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ebu\\Sram -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ebu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Edsadc\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Edsadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Emem\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Eray\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Eray\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Evadc\\Adc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Evadc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Fce\\Crc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Fce\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Flash\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gpt12\\IncrEnc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gpt12\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Atom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\In -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tim\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Dtm_PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Pwm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\PwmHl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Tom\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm\\Trig -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Hspdm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Hspdm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Hssl\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Hssl\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\I2c\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\I2c\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Iom\\Driver -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Iom\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Iom\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Msc\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Msc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Mtu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Pms\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5s\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5s\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiMaster -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Qspi\\SpiSlave -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Qspi\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Rif\\Rif -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Rif\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sdmmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Emmc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Sd -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sdmmc\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sent\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sent\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Smu\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Smu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Spu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Spu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Lin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Spi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Geth\\Eth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Geth\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Scu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Config -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Config\\Common -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\_Utilities -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\If\\Ccu6If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Bsp -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Comm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\General -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Math -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe\\Time -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\2_CDrv -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Build -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib\\DataHandling -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib\\InternalMux -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Reg -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Asclin -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can\\Can -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Can\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Ccu6 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Convctrl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\CStart -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\Irq -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Cpu\\Trap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dma -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Dts -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Edsadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Emem -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Eray -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Evadc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Fce -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Flash -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Geth -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gpt12 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Gtm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Hssl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\I2c -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Iom -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Msc -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Mtu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Pms -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Port -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Port\\Io -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Port\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5 -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Psi5s -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Qspi -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Scu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Sent -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Smu -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Src -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Src\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Stm -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Stm\\Std -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\Stm\\Timer -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\Main -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\If -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\StdIf -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\SysSe -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\1_SrvSw\\Tricore\\Compilers -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Impl -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Lib -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_PinMap -ID:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\4_McHal\\Tricore\\_Reg -g2 --make-target=0_Src\\0_AppSw\\Tricore\\rt-thread\\src\\slab.o -t4 --language=-gcc,-volatile,+strings,-kanji --default-near-size=8 -O2 --default-a1-size=0 --default-a0-size=0 --source --align=0 --compact-max-size=200 --switch=auto --error-limit=42 -o 0_Src\\0_AppSw\\Tricore\\rt-thread\\src\\slab.src ..\\0_Src\\0_AppSw\\Tricore\\rt-thread\\src\\slab.c"
	.compiler_name		"ctc"
	;source	'..\\0_Src\\0_AppSw\\Tricore\\rt-thread\\src\\slab.c'

	
$TC162
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	964
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'..\\0_Src\\0_AppSw\\Tricore\\rt-thread\\src\\slab.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\Debug\\',0,12,1
	.word	.L5
	.byte	2
	.byte	'int',0,4,5,3
	.word	168
	.byte	4
	.byte	'__c11_atomic_thread_fence',0,1,1,1,1,5
	.word	175
	.byte	0,2
	.byte	'unsigned int',0,4,7,6
	.word	217
	.byte	7
	.word	217
	.byte	8
	.byte	'__cmpswapw',0
	.word	233
	.byte	1,1,1,1,9
	.byte	'p',0
	.word	238
	.byte	9
	.byte	'value',0
	.word	217
	.byte	9
	.byte	'compare',0
	.word	217
	.byte	0,10
	.byte	'__size_t',0,1,1,1
	.word	217
	.byte	11,1,7
	.word	312
	.byte	10
	.byte	'__codeptr',0,1,1,1
	.word	314
	.byte	10
	.byte	'__intptr_t',0,1,1,1
	.word	168
	.byte	10
	.byte	'__uintptr_t',0,1,1,1
	.word	217
	.byte	2
	.byte	'unsigned char',0,1,8,10
	.byte	'rt_uint8_t',0,2,69,41
	.word	376
	.byte	2
	.byte	'unsigned short int',0,2,7,10
	.byte	'rt_uint16_t',0,2,70,41
	.word	412
	.byte	10
	.byte	'rt_uint32_t',0,2,71,41
	.word	217
	.byte	2
	.byte	'long int',0,4,5,10
	.byte	'rt_base_t',0,2,83,41
	.word	474
	.byte	2
	.byte	'unsigned long int',0,4,7,10
	.byte	'rt_ubase_t',0,2,84,41
	.word	504
	.byte	10
	.byte	'rt_err_t',0,2,86,41
	.word	474
	.byte	10
	.byte	'rt_tick_t',0,2,88,41
	.word	217
	.byte	10
	.byte	'rt_size_t',0,2,90,41
	.word	504
	.byte	7
	.word	.L6-.L3
.L6:
	.byte	12
	.byte	'rt_list_node',0,2,229,2,8,8,13
	.byte	'next',0
	.word	597
	.byte	4,2,35,0,13
	.byte	'prev',0
	.word	597
	.byte	4,2,35,4,0,10
	.byte	'rt_list_t',0,2,234,2,29
	.word	602
	.byte	7
	.word	.L7-.L3
.L7:
	.byte	12
	.byte	'rt_slist_node',0,2,239,2,8,4,13
	.byte	'next',0
	.word	669
	.byte	4,2,35,0,0,10
	.byte	'rt_slist_t',0,2,243,2,30
	.word	674
	.byte	10
	.byte	'uint16_t',0,3,246,1,41
	.word	412
	.byte	10
	.byte	'uint32_t',0,3,254,1,41
	.word	217
	.byte	10
	.byte	'time_t',0,4,44,25
	.word	504
	.byte	10
	.byte	'fd_mask',0,5,39,17
	.word	474
	.byte	14
	.byte	'void',0,7
	.word	796
	.byte	15,1,1,5
	.word	168
	.byte	5
	.word	802
	.byte	0,7
	.word	807
	.byte	10
	.byte	'rt_isr_handler_t',0,6,73,16
	.word	821
	.byte	12
	.byte	'__arch_tickets',0,6,140,1,12,4,13
	.byte	'owner',0
	.word	412
	.byte	2,2,35,0,13
	.byte	'next',0
	.word	412
	.byte	2,2,35,2,0,16,6,138,1,9,4,13
	.byte	'slock',0
	.word	504
	.byte	4,2,35,0,13
	.byte	'tickets',0
	.word	851
	.byte	4,2,35,0,0,10
	.byte	'rt_hw_spinlock_t',0,6,144,1,3
	.word	902
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,38,0,73,19,0,0,4,46,1,3,8,54
	.byte	15,39,12,63,12,60,12,0,0,5,5,0,73,19,0,0,6,53,0,73,19,0,0,7,15,0,73,19,0,0,8,46,1,3,8,73,19,54,15,39,12
	.byte	63,12,60,12,0,0,9,5,0,3,8,73,19,0,0,10,22,0,3,8,58,15,59,15,57,15,73,19,0,0,11,21,0,54,15,0,0,12,19,1
	.byte	3,8,58,15,59,15,57,15,11,15,0,0,13,13,0,3,8,73,19,11,15,56,9,0,0,14,59,0,3,8,0,0,15,21,1,54,15,39,12,0
	.byte	0,16,23,1,58,15,59,15,57,15,11,15,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L9-.L8
.L8:
	.half	3
	.word	.L11-.L10
.L10:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread\\include',0
	.byte	'D:\\App\\Tasking6_3_Install\\ctc\\include\\',0
	.byte	'D:\\WorkSpace\\Tasking\\Tasking_TC397_MultiCore_RTThread\\0_Src\\0_AppSw\\Tricore\\rt-thread\\include\\libc',0
	.byte	0
	.byte	'..\\0_Src\\0_AppSw\\Tricore\\rt-thread\\src\\slab.c',0,0,0,0
	.byte	'rtdef.h',0,1,0,0
	.byte	'stdint.h',0,2,0,0
	.byte	'time.h',0,2,0,0
	.byte	'libc_fdset.h',0,3,0,0
	.byte	'rthw.h',0,1,0,0,0
.L11:
.L9:

; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     1  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     2   * Copyright (c) 2006-2021, RT-Thread Development Team
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     3   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     4   * SPDX-License-Identifier: Apache-2.0
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     5   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     6  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     7  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     8   * File      : slab.c
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	     9   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    10   * Change Logs:
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    11   * Date           Author       Notes
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    12   * 2008-07-12     Bernard      the first version
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    13   * 2010-07-13     Bernard      fix RT_ALIGN issue found by kuronca
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    14   * 2010-10-23     yi.qiu       add module memory allocator
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    15   * 2010-12-18     yi.qiu       fix zone release bug
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    16   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    17  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    18  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    19   * KERN_SLABALLOC.C - Kernel SLAB memory allocator
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    20   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    21   * Copyright (c) 2003,2004 The DragonFly Project.  All rights reserved.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    22   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    23   * This code is derived from software contributed to The DragonFly Project
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    24   * by Matthew Dillon <dillon@backplane.com>
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    25   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    26   * Redistribution and use in source and binary forms, with or without
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    27   * modification, are permitted provided that the following conditions
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    28   * are met:
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    29   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    30   * 1. Redistributions of source code must retain the above copyright
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    31   *    notice, this list of conditions and the following disclaimer.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    32   * 2. Redistributions in binary form must reproduce the above copyright
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    33   *    notice, this list of conditions and the following disclaimer in
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    34   *    the documentation and/or other materials provided with the
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    35   *    distribution.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    36   * 3. Neither the name of The DragonFly Project nor the names of its
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    37   *    contributors may be used to endorse or promote products derived
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    38   *    from this software without specific, prior written permission.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    39   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    40   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    41   * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    42   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    43   * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    44   * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    45   * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    46   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    47   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    48   * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    49   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    50   * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    51   * SUCH DAMAGE.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    52   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    53   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    54  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    55  #include <rthw.h>
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    56  #include <rtthread.h>
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    57  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    58  #define RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    59  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    60  #if defined (RT_USING_HEAP) && defined (RT_USING_SLAB)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    61  /* some statistical variable */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    62  #ifdef RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    63  static rt_size_t used_mem, max_mem;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    64  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    65  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    66  #ifdef RT_USING_HOOK
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    67  static void (*rt_malloc_hook)(void *ptr, rt_size_t size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    68  static void (*rt_free_hook)(void *ptr);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    69  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    70  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    71   * @addtogroup Hook
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    72   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    73  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    74  /**@{*/
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    75  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    76  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    77   * This function will set a hook function, which will be invoked when a memory
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    78   * block is allocated from heap memory.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    79   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    80   * @param hook the hook function
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    81   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    82  void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    83  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    84      rt_malloc_hook = hook;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    85  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    86  RTM_EXPORT(rt_malloc_sethook);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    87  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    88  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    89   * This function will set a hook function, which will be invoked when a memory
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    90   * block is released to heap memory.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    91   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    92   * @param hook the hook function
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    93   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    94  void rt_free_sethook(void (*hook)(void *ptr))
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    95  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    96      rt_free_hook = hook;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    97  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    98  RTM_EXPORT(rt_free_sethook);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	    99  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   100  /**@}*/
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   101  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   102  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   103  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   104  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   105   * slab allocator implementation
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   106   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   107   * A slab allocator reserves a ZONE for each chunk size, then lays the
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   108   * chunks out in an array within the zone.  Allocation and deallocation
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   109   * is nearly instantanious, and fragmentation/overhead losses are limited
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   110   * to a fixed worst-case amount.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   111   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   112   * The downside of this slab implementation is in the chunk size
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   113   * multiplied by the number of zones.  ~80 zones * 128K = 10MB of VM per cpu.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   114   * In a kernel implementation all this memory will be physical so
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   115   * the zone size is adjusted downward on machines with less physical
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   116   * memory.  The upside is that overhead is bounded... this is the *worst*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   117   * case overhead.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   118   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   119   * Slab management is done on a per-cpu basis and no locking or mutexes
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   120   * are required, only a critical section.  When one cpu frees memory
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   121   * belonging to another cpu's slab manager an asynchronous IPI message
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   122   * will be queued to execute the operation.   In addition, both the
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   123   * high level slab allocator and the low level zone allocator optimize
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   124   * M_ZERO requests, and the slab allocator does not have to pre initialize
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   125   * the linked list of chunks.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   126   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   127   * XXX Balancing is needed between cpus.  Balance will be handled through
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   128   * asynchronous IPIs primarily by reassigning the z_Cpu ownership of chunks.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   129   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   130   * XXX If we have to allocate a new zone and M_USE_RESERVE is set, use of
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   131   * the new zone should be restricted to M_USE_RESERVE requests only.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   132   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   133   *  Alloc Size  Chunking        Number of zones
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   134   *  0-127       8               16
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   135   *  128-255     16              8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   136   *  256-511     32              8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   137   *  512-1023    64              8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   138   *  1024-2047   128             8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   139   *  2048-4095   256             8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   140   *  4096-8191   512             8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   141   *  8192-16383  1024            8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   142   *  16384-32767 2048            8
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   143   *  (if RT_MM_PAGE_SIZE is 4K the maximum zone allocation is 16383)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   144   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   145   *  Allocations >= zone_limit go directly to kmem.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   146   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   147   *          API REQUIREMENTS AND SIDE EFFECTS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   148   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   149   *    To operate as a drop-in replacement to the FreeBSD-4.x malloc() we
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   150   *    have remained compatible with the following API requirements:
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   151   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   152   *    + small power-of-2 sized allocations are power-of-2 aligned (kern_tty)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   153   *    + all power-of-2 sized allocations are power-of-2 aligned (twe)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   154   *    + malloc(0) is allowed and returns non-RT_NULL (ahc driver)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   155   *    + ability to allocate arbitrarily large chunks of memory
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   156   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   157  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   158  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   159   * Chunk structure for free elements
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   160   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   161  typedef struct slab_chunk
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   162  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   163      struct slab_chunk *c_next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   164  } slab_chunk;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   165  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   166  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   167   * The IN-BAND zone header is placed at the beginning of each zone.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   168   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   169  typedef struct slab_zone
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   170  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   171      rt_int32_t  z_magic;        /* magic number for sanity check */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   172      rt_int32_t  z_nfree;        /* total free chunks / ualloc space in zone */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   173      rt_int32_t  z_nmax;         /* maximum free chunks */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   174  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   175      struct slab_zone *z_next;   /* zoneary[] link if z_nfree non-zero */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   176      rt_uint8_t  *z_baseptr;     /* pointer to start of chunk array */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   177  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   178      rt_int32_t  z_uindex;       /* current initial allocation index */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   179      rt_int32_t  z_chunksize;    /* chunk size for validation */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   180  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   181      rt_int32_t  z_zoneindex;    /* zone index */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   182      slab_chunk  *z_freechunk;   /* free chunk list */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   183  } slab_zone;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   184  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   185  #define ZALLOC_SLAB_MAGIC       0x51ab51ab
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   186  #define ZALLOC_ZONE_LIMIT       (16 * 1024)     /* max slab-managed alloc */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   187  #define ZALLOC_MIN_ZONE_SIZE    (32 * 1024)     /* minimum zone size */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   188  #define ZALLOC_MAX_ZONE_SIZE    (128 * 1024)    /* maximum zone size */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   189  #define NZONES                  72              /* number of zones */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   190  #define ZONE_RELEASE_THRESH     2               /* threshold number of zones */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   191  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   192  static slab_zone *zone_array[NZONES];   /* linked list of zones NFree > 0 */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   193  static slab_zone *zone_free;            /* whole zones that have become free */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   194  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   195  static int zone_free_cnt;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   196  static int zone_size;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   197  static int zone_limit;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   198  static int zone_page_cnt;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   199  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   200  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   201   * Misc constants.  Note that allocations that are exact multiples of
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   202   * RT_MM_PAGE_SIZE, or exceed the zone limit, fall through to the kmem module.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   203   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   204  #define MIN_CHUNK_SIZE      8       /* in bytes */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   205  #define MIN_CHUNK_MASK      (MIN_CHUNK_SIZE - 1)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   206  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   207  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   208   * Array of descriptors that describe the contents of each page
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   209   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   210  #define PAGE_TYPE_FREE      0x00
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   211  #define PAGE_TYPE_SMALL     0x01
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   212  #define PAGE_TYPE_LARGE     0x02
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   213  struct memusage
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   214  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   215      rt_uint32_t type: 2 ;       /* page type */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   216      rt_uint32_t size: 30;       /* pages allocated or offset from zone */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   217  };
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   218  static struct memusage *memusage = RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   219  #define btokup(addr)    \ 
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   220      (&memusage[((rt_ubase_t)(addr) - heap_start) >> RT_MM_PAGE_BITS])
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   221  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   222  static rt_ubase_t heap_start, heap_end;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   223  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   224  /* page allocator */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   225  struct rt_page_head
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   226  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   227      struct rt_page_head *next;      /* next valid page */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   228      rt_size_t page;                 /* number of page  */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   229  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   230      /* dummy */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   231      char dummy[RT_MM_PAGE_SIZE - (sizeof(struct rt_page_head *) + sizeof(rt_size_t))];
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   232  };
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   233  static struct rt_page_head *rt_page_list;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   234  static struct rt_semaphore heap_sem;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   235  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   236  void *rt_page_alloc(rt_size_t npages)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   237  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   238      struct rt_page_head *b, *n;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   239      struct rt_page_head **prev;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   240  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   241      if (npages == 0)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   242          return RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   243  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   244      /* lock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   245      rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   246      for (prev = &rt_page_list; (b = *prev) != RT_NULL; prev = &(b->next))
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   247      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   248          if (b->page > npages)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   249          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   250              /* splite pages */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   251              n       = b + npages;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   252              n->next = b->next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   253              n->page = b->page - npages;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   254              *prev   = n;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   255              break;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   256          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   257  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   258          if (b->page == npages)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   259          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   260              /* this node fit, remove this node */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   261              *prev = b->next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   262              break;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   263          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   264      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   265  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   266      /* unlock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   267      rt_sem_release(&heap_sem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   268  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   269      return b;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   270  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   271  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   272  void rt_page_free(void *addr, rt_size_t npages)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   273  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   274      struct rt_page_head *b, *n;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   275      struct rt_page_head **prev;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   276  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   277      RT_ASSERT(addr != RT_NULL);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   278      RT_ASSERT((rt_ubase_t)addr % RT_MM_PAGE_SIZE == 0);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   279      RT_ASSERT(npages != 0);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   280  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   281      n = (struct rt_page_head *)addr;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   282  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   283      /* lock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   284      rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   285  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   286      for (prev = &rt_page_list; (b = *prev) != RT_NULL; prev = &(b->next))
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   287      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   288          RT_ASSERT(b->page > 0);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   289          RT_ASSERT(b > n || b + b->page <= n);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   290  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   291          if (b + b->page == n)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   292          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   293              if (b + (b->page += npages) == b->next)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   294              {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   295                  b->page += b->next->page;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   296                  b->next  = b->next->next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   297              }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   298  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   299              goto _return;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   300          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   301  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   302          if (b == n + npages)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   303          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   304              n->page = b->page + npages;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   305              n->next = b->next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   306              *prev   = n;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   307  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   308              goto _return;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   309          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   310  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   311          if (b > n + npages)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   312              break;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   313      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   314  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   315      n->page = npages;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   316      n->next = b;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   317      *prev   = n;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   318  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   319  _return:
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   320      /* unlock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   321      rt_sem_release(&heap_sem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   322  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   323  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   324  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   325   * Initialize the page allocator
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   326   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   327  static void rt_page_init(void *addr, rt_size_t npages)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   328  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   329      RT_ASSERT(addr != RT_NULL);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   330      RT_ASSERT(npages != 0);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   331  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   332      rt_page_list = RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   333      rt_page_free(addr, npages);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   334  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   335  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   336  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   337   * @ingroup SystemInit
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   338   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   339   * This function will init system heap
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   340   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   341   * @param begin_addr the beginning address of system page
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   342   * @param end_addr the end address of system page
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   343   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   344  void rt_system_heap_init(void *begin_addr, void *end_addr)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   345  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   346      rt_uint32_t limsize, npages;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   347  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   348      RT_DEBUG_NOT_IN_INTERRUPT;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   349  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   350      /* align begin and end addr to page */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   351      heap_start = RT_ALIGN((rt_ubase_t)begin_addr, RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   352      heap_end   = RT_ALIGN_DOWN((rt_ubase_t)end_addr, RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   353  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   354      if (heap_start >= heap_end)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   355      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   356          rt_kprintf("rt_system_heap_init, wrong address[0x%x - 0x%x]\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   357                     (rt_ubase_t)begin_addr, (rt_ubase_t)end_addr);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   358  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   359          return;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   360      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   361  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   362      limsize = heap_end - heap_start;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   363      npages  = limsize / RT_MM_PAGE_SIZE;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   364  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   365      /* initialize heap semaphore */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   366      rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   367  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   368      RT_DEBUG_LOG(RT_DEBUG_SLAB, ("heap[0x%x - 0x%x], size 0x%x, 0x%x pages\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   369                                   heap_start, heap_end, limsize, npages));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   370  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   371      /* init pages */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   372      rt_page_init((void *)heap_start, npages);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   373  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   374      /* calculate zone size */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   375      zone_size = ZALLOC_MIN_ZONE_SIZE;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   376      while (zone_size < ZALLOC_MAX_ZONE_SIZE && (zone_size << 1) < (limsize / 1024))
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   377          zone_size <<= 1;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   378  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   379      zone_limit = zone_size / 4;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   380      if (zone_limit > ZALLOC_ZONE_LIMIT)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   381          zone_limit = ZALLOC_ZONE_LIMIT;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   382  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   383      zone_page_cnt = zone_size / RT_MM_PAGE_SIZE;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   384  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   385      RT_DEBUG_LOG(RT_DEBUG_SLAB, ("zone size 0x%x, zone page count 0x%x\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   386                                   zone_size, zone_page_cnt));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   387  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   388      /* allocate memusage array */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   389      limsize  = npages * sizeof(struct memusage);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   390      limsize  = RT_ALIGN(limsize, RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   391      memusage = rt_page_alloc(limsize / RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   392  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   393      RT_DEBUG_LOG(RT_DEBUG_SLAB, ("memusage 0x%x, size 0x%x\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   394                                   (rt_ubase_t)memusage, limsize));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   395  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   396  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   397  /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   398   * Calculate the zone index for the allocation request size and set the
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   399   * allocation request size to that particular zone's chunk size.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   400   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   401  rt_inline int zoneindex(rt_size_t *bytes)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   402  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   403      /* unsigned for shift opt */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   404      rt_ubase_t n = (rt_ubase_t)(*bytes);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   405  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   406      if (n < 128)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   407      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   408          *bytes = n = (n + 7) & ~7;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   409  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   410          /* 8 byte chunks, 16 zones */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   411          return (n / 8 - 1);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   412      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   413      if (n < 256)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   414      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   415          *bytes = n = (n + 15) & ~15;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   416  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   417          return (n / 16 + 7);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   418      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   419      if (n < 8192)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   420      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   421          if (n < 512)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   422          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   423              *bytes = n = (n + 31) & ~31;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   424  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   425              return (n / 32 + 15);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   426          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   427          if (n < 1024)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   428          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   429              *bytes = n = (n + 63) & ~63;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   430  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   431              return (n / 64 + 23);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   432          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   433          if (n < 2048)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   434          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   435              *bytes = n = (n + 127) & ~127;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   436  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   437              return (n / 128 + 31);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   438          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   439          if (n < 4096)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   440          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   441              *bytes = n = (n + 255) & ~255;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   442  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   443              return (n / 256 + 39);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   444          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   445          *bytes = n = (n + 511) & ~511;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   446  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   447          return (n / 512 + 47);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   448      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   449      if (n < 16384)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   450      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   451          *bytes = n = (n + 1023) & ~1023;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   452  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   453          return (n / 1024 + 55);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   454      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   455  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   456      rt_kprintf("Unexpected byte count %d", n);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   457  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   458      return 0;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   459  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   460  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   461  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   462   * @addtogroup MM
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   463   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   464  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   465  /**@{*/
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   466  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   467  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   468   * This function will allocate a block from system heap memory.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   469   * - If the nbytes is less than zero,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   470   * or
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   471   * - If there is no nbytes sized memory valid in system,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   472   * the RT_NULL is returned.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   473   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   474   * @param size the size of memory to be allocated
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   475   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   476   * @return the allocated memory
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   477   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   478  void *rt_malloc(rt_size_t size)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   479  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   480      slab_zone *z;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   481      rt_int32_t zi;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   482      slab_chunk *chunk;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   483      struct memusage *kup;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   484  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   485      /* zero size, return RT_NULL */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   486      if (size == 0)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   487          return RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   488  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   489      /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   490       * Handle large allocations directly.  There should not be very many of
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   491       * these so performance is not a big issue.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   492       */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   493      if (size >= zone_limit)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   494      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   495          size = RT_ALIGN(size, RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   496  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   497          chunk = rt_page_alloc(size >> RT_MM_PAGE_BITS);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   498          if (chunk == RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   499              return RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   500  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   501          /* set kup */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   502          kup = btokup(chunk);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   503          kup->type = PAGE_TYPE_LARGE;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   504          kup->size = size >> RT_MM_PAGE_BITS;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   505  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   506          RT_DEBUG_LOG(RT_DEBUG_SLAB,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   507                       ("malloc a large memory 0x%x, page cnt %d, kup %d\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   508                        size,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   509                        size >> RT_MM_PAGE_BITS,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   510                        ((rt_ubase_t)chunk - heap_start) >> RT_MM_PAGE_BITS));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   511  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   512          /* lock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   513          rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   514  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   515  #ifdef RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   516          used_mem += size;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   517          if (used_mem > max_mem)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   518              max_mem = used_mem;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   519  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   520          goto done;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   521      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   522  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   523      /* lock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   524      rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   525  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   526      /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   527       * Attempt to allocate out of an existing zone.  First try the free list,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   528       * then allocate out of unallocated space.  If we find a good zone move
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   529       * it to the head of the list so later allocations find it quickly
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   530       * (we might have thousands of zones in the list).
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   531       *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   532       * Note: zoneindex() will panic of size is too large.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   533       */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   534      zi = zoneindex(&size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   535      RT_ASSERT(zi < NZONES);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   536  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   537      RT_DEBUG_LOG(RT_DEBUG_SLAB, ("try to malloc 0x%x on zone: %d\n", size, zi));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   538  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   539      if ((z = zone_array[zi]) != RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   540      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   541          RT_ASSERT(z->z_nfree > 0);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   542  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   543          /* Remove us from the zone_array[] when we become empty */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   544          if (--z->z_nfree == 0)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   545          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   546              zone_array[zi] = z->z_next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   547              z->z_next = RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   548          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   549  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   550          /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   551           * No chunks are available but nfree said we had some memory, so
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   552           * it must be available in the never-before-used-memory area
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   553           * governed by uindex.  The consequences are very serious if our zone
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   554           * got corrupted so we use an explicit rt_kprintf rather then a KASSERT.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   555           */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   556          if (z->z_uindex + 1 != z->z_nmax)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   557          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   558              z->z_uindex = z->z_uindex + 1;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   559              chunk = (slab_chunk *)(z->z_baseptr + z->z_uindex * size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   560          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   561          else
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   562          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   563              /* find on free chunk list */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   564              chunk = z->z_freechunk;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   565  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   566              /* remove this chunk from list */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   567              z->z_freechunk = z->z_freechunk->c_next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   568          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   569  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   570  #ifdef RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   571          used_mem += z->z_chunksize;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   572          if (used_mem > max_mem)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   573              max_mem = used_mem;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   574  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   575  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   576          goto done;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   577      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   578  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   579      /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   580       * If all zones are exhausted we need to allocate a new zone for this
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   581       * index.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   582       *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   583       * At least one subsystem, the tty code (see CROUND) expects power-of-2
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   584       * allocations to be power-of-2 aligned.  We maintain compatibility by
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   585       * adjusting the base offset below.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   586       */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   587      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   588          rt_int32_t off;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   589  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   590          if ((z = zone_free) != RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   591          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   592              /* remove zone from free zone list */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   593              zone_free = z->z_next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   594              -- zone_free_cnt;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   595          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   596          else
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   597          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   598              /* unlock heap, since page allocator will think about lock */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   599              rt_sem_release(&heap_sem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   600  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   601              /* allocate a zone from page */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   602              z = rt_page_alloc(zone_size / RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   603              if (z == RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   604              {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   605                  chunk = RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   606                  goto __exit;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   607              }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   608  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   609              /* lock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   610              rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   611  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   612              RT_DEBUG_LOG(RT_DEBUG_SLAB, ("alloc a new zone: 0x%x\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   613                                           (rt_ubase_t)z));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   614  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   615              /* set message usage */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   616              for (off = 0, kup = btokup(z); off < zone_page_cnt; off ++)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   617              {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   618                  kup->type = PAGE_TYPE_SMALL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   619                  kup->size = off;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   620  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   621                  kup ++;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   622              }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   623          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   624  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   625          /* clear to zero */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   626          rt_memset(z, 0, sizeof(slab_zone));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   627  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   628          /* offset of slab zone struct in zone */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   629          off = sizeof(slab_zone);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   630  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   631          /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   632           * Guarentee power-of-2 alignment for power-of-2-sized chunks.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   633           * Otherwise just 8-byte align the data.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   634           */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   635          if ((size | (size - 1)) + 1 == (size << 1))
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   636              off = (off + size - 1) & ~(size - 1);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   637          else
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   638              off = (off + MIN_CHUNK_MASK) & ~MIN_CHUNK_MASK;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   639  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   640          z->z_magic     = ZALLOC_SLAB_MAGIC;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   641          z->z_zoneindex = zi;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   642          z->z_nmax      = (zone_size - off) / size;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   643          z->z_nfree     = z->z_nmax - 1;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   644          z->z_baseptr   = (rt_uint8_t *)z + off;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   645          z->z_uindex    = 0;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   646          z->z_chunksize = size;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   647  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   648          chunk = (slab_chunk *)(z->z_baseptr + z->z_uindex * size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   649  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   650          /* link to zone array */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   651          z->z_next = zone_array[zi];
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   652          zone_array[zi] = z;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   653  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   654  #ifdef RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   655          used_mem += z->z_chunksize;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   656          if (used_mem > max_mem)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   657              max_mem = used_mem;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   658  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   659      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   660  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   661  done:
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   662      rt_sem_release(&heap_sem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   663      RT_OBJECT_HOOK_CALL(rt_malloc_hook, ((char *)chunk, size));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   664  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   665  __exit:
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   666      return chunk;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   667  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   668  RTM_EXPORT(rt_malloc);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   669  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   670  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   671   * This function will change the size of previously allocated memory block.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   672   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   673   * @param ptr the previously allocated memory block
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   674   * @param size the new size of memory block
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   675   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   676   * @return the allocated memory
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   677   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   678  void *rt_realloc(void *ptr, rt_size_t size)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   679  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   680      void *nptr;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   681      slab_zone *z;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   682      struct memusage *kup;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   683  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   684      if (ptr == RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   685          return rt_malloc(size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   686      if (size == 0)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   687      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   688          rt_free(ptr);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   689  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   690          return RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   691      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   692  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   693      /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   694       * Get the original allocation's zone.  If the new request winds up
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   695       * using the same chunk size we do not have to do anything.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   696       */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   697      kup = btokup((rt_ubase_t)ptr & ~RT_MM_PAGE_MASK);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   698      if (kup->type == PAGE_TYPE_LARGE)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   699      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   700          rt_size_t osize;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   701  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   702          osize = kup->size << RT_MM_PAGE_BITS;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   703          if ((nptr = rt_malloc(size)) == RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   704              return RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   705          rt_memcpy(nptr, ptr, size > osize ? osize : size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   706          rt_free(ptr);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   707  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   708          return nptr;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   709      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   710      else if (kup->type == PAGE_TYPE_SMALL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   711      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   712          z = (slab_zone *)(((rt_ubase_t)ptr & ~RT_MM_PAGE_MASK) -
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   713                            kup->size * RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   714          RT_ASSERT(z->z_magic == ZALLOC_SLAB_MAGIC);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   715  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   716          zoneindex(&size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   717          if (z->z_chunksize == size)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   718              return (ptr); /* same chunk */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   719  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   720          /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   721           * Allocate memory for the new request size.  Note that zoneindex has
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   722           * already adjusted the request size to the appropriate chunk size, which
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   723           * should optimize our bcopy().  Then copy and return the new pointer.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   724           */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   725          if ((nptr = rt_malloc(size)) == RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   726              return RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   727  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   728          rt_memcpy(nptr, ptr, size > z->z_chunksize ? z->z_chunksize : size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   729          rt_free(ptr);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   730  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   731          return nptr;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   732      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   733  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   734      return RT_NULL;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   735  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   736  RTM_EXPORT(rt_realloc);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   737  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   738  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   739   * This function will contiguously allocate enough space for count objects
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   740   * that are size bytes of memory each and returns a pointer to the allocated
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   741   * memory.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   742   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   743   * The allocated memory is filled with bytes of value zero.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   744   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   745   * @param count number of objects to allocate
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   746   * @param size size of the objects to allocate
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   747   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   748   * @return pointer to allocated memory / NULL pointer if there is an error
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   749   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   750  void *rt_calloc(rt_size_t count, rt_size_t size)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   751  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   752      void *p;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   753  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   754      /* allocate 'count' objects of size 'size' */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   755      p = rt_malloc(count * size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   756  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   757      /* zero the memory */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   758      if (p)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   759          rt_memset(p, 0, count * size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   760  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   761      return p;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   762  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   763  RTM_EXPORT(rt_calloc);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   764  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   765  /**
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   766   * This function will release the previous allocated memory block by rt_malloc.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   767   * The released memory block is taken back to system heap.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   768   *
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   769   * @param ptr the address of memory which will be released
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   770   */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   771  void rt_free(void *ptr)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   772  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   773      slab_zone *z;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   774      slab_chunk *chunk;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   775      struct memusage *kup;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   776  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   777      /* free a RT_NULL pointer */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   778      if (ptr == RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   779          return ;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   780  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   781      RT_OBJECT_HOOK_CALL(rt_free_hook, (ptr));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   782  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   783      /* get memory usage */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   784  #if RT_DEBUG_SLAB
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   785      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   786          rt_ubase_t addr = ((rt_ubase_t)ptr & ~RT_MM_PAGE_MASK);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   787          RT_DEBUG_LOG(RT_DEBUG_SLAB,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   788                       ("free a memory 0x%x and align to 0x%x, kup index %d\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   789                        (rt_ubase_t)ptr,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   790                        (rt_ubase_t)addr,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   791                        ((rt_ubase_t)(addr) - heap_start) >> RT_MM_PAGE_BITS));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   792      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   793  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   794  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   795      kup = btokup((rt_ubase_t)ptr & ~RT_MM_PAGE_MASK);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   796      /* release large allocation */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   797      if (kup->type == PAGE_TYPE_LARGE)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   798      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   799          rt_ubase_t size;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   800  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   801          /* lock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   802          rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   803          /* clear page counter */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   804          size = kup->size;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   805          kup->size = 0;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   806  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   807  #ifdef RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   808          used_mem -= size * RT_MM_PAGE_SIZE;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   809  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   810          rt_sem_release(&heap_sem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   811  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   812          RT_DEBUG_LOG(RT_DEBUG_SLAB,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   813                       ("free large memory block 0x%x, page count %d\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   814                        (rt_ubase_t)ptr, size));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   815  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   816          /* free this page */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   817          rt_page_free(ptr, size);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   818  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   819          return;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   820      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   821  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   822      /* lock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   823      rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   824  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   825      /* zone case. get out zone. */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   826      z = (slab_zone *)(((rt_ubase_t)ptr & ~RT_MM_PAGE_MASK) -
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   827                        kup->size * RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   828      RT_ASSERT(z->z_magic == ZALLOC_SLAB_MAGIC);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   829  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   830      chunk          = (slab_chunk *)ptr;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   831      chunk->c_next  = z->z_freechunk;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   832      z->z_freechunk = chunk;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   833  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   834  #ifdef RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   835      used_mem -= z->z_chunksize;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   836  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   837  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   838      /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   839       * Bump the number of free chunks.  If it becomes non-zero the zone
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   840       * must be added back onto the appropriate list.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   841       */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   842      if (z->z_nfree++ == 0)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   843      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   844          z->z_next = zone_array[z->z_zoneindex];
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   845          zone_array[z->z_zoneindex] = z;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   846      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   847  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   848      /*
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   849       * If the zone becomes totally free, and there are other zones we
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   850       * can allocate from, move this zone to the FreeZones list.  Since
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   851       * this code can be called from an IPI callback, do *NOT* try to mess
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   852       * with kernel_map here.  Hysteresis will be performed at malloc() time.
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   853       */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   854      if (z->z_nfree == z->z_nmax &&
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   855          (z->z_next || zone_array[z->z_zoneindex] != z))
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   856      {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   857          slab_zone **pz;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   858  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   859          RT_DEBUG_LOG(RT_DEBUG_SLAB, ("free zone 0x%x\n",
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   860                                       (rt_ubase_t)z, z->z_zoneindex));
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   861  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   862          /* remove zone from zone array list */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   863          for (pz = &zone_array[z->z_zoneindex]; z != *pz; pz = &(*pz)->z_next)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   864              ;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   865          *pz = z->z_next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   866  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   867          /* reset zone */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   868          z->z_magic = -1;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   869  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   870          /* insert to free zone list */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   871          z->z_next = zone_free;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   872          zone_free = z;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   873  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   874          ++ zone_free_cnt;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   875  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   876          /* release zone to page allocator */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   877          if (zone_free_cnt > ZONE_RELEASE_THRESH)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   878          {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   879              register rt_base_t i;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   880  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   881              z         = zone_free;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   882              zone_free = z->z_next;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   883              -- zone_free_cnt;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   884  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   885              /* set message usage */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   886              for (i = 0, kup = btokup(z); i < zone_page_cnt; i ++)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   887              {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   888                  kup->type = PAGE_TYPE_FREE;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   889                  kup->size = 0;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   890                  kup ++;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   891              }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   892  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   893              /* unlock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   894              rt_sem_release(&heap_sem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   895  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   896              /* release pages */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   897              rt_page_free(z, zone_size / RT_MM_PAGE_SIZE);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   898  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   899              return;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   900          }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   901      }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   902      /* unlock heap */
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   903      rt_sem_release(&heap_sem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   904  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   905  RTM_EXPORT(rt_free);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   906  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   907  #ifdef RT_MEM_STATS
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   908  void rt_memory_info(rt_uint32_t *total,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   909                      rt_uint32_t *used,
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   910                      rt_uint32_t *max_used)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   911  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   912      if (total != RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   913          *total = heap_end - heap_start;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   914  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   915      if (used  != RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   916          *used = used_mem;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   917  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   918      if (max_used != RT_NULL)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   919          *max_used = max_mem;
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   920  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   921  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   922  #ifdef RT_USING_FINSH
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   923  #include <finsh.h>
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   924  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   925  void list_mem(void)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   926  {
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   927      rt_kprintf("total memory: %d\n", heap_end - heap_start);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   928      rt_kprintf("used memory : %d\n", used_mem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   929      rt_kprintf("maximum allocated memory: %d\n", max_mem);
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   930  }
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   931  FINSH_FUNCTION_EXPORT(list_mem, list memory usage information)
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   932  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   933  #endif
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   934  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   935  /**@}*/
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   936  
; ..\0_Src\0_AppSw\Tricore\rt-thread\src\slab.c	   937  #endif

	; Module end
